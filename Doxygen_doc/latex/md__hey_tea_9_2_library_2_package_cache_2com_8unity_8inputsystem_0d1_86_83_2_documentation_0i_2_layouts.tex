\chapter{Layouts}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts}{}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts}\index{Layouts@{Layouts}}
\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts_autotoc_md1430}%
\Hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts_autotoc_md1430}%

\begin{DoxyItemize}
\item Layout formats
\begin{DoxyItemize}
\item Layout from type
\item Layout from JSON
\item Generated layouts
\end{DoxyItemize}
\item Layout inheritance
\item Control items
\item Layout overrides
\item Precompiled layouts
\begin{DoxyItemize}
\item Creating a precompiled layout
\end{DoxyItemize}
\end{DoxyItemize}

Layouts are the central mechanism by which the Input \doxylink{namespace_system}{System} learns about types of Input Devices and Input Controls. Each layout represents a specific composition of Input Controls. By matching the description of a Device to a layout, the Input \doxylink{namespace_system}{System} is able to create the correct type of Device and interpret the incoming input data correctly.

\texorpdfstring{$>$}{>}{\bfseries{Note}}\+: Layouts are an advanced, mostly internal feature of the Input \doxylink{namespace_system}{System}. Knowledge of the layout system is mostly useful if you want to support custom Devices or change the behavior of existing Devices.

A layout describes a memory format for input, and the Input Controls to build in order to read and write data to or from that memory.

The Input \doxylink{namespace_system}{System} ships with a large set of layouts for common Control types and common Devices. For other Device types, the system automatically generates layouts based on the Device description that the Device\textquotesingle{}s interface reports.

You can browse the set of currently understood layouts from the Input Debugger.



A layout has two primary functions\+:


\begin{DoxyItemize}
\item Describe a certain memory layout containing input data.
\item Assign names, structure, and meaning to the Controls operating on the data.
\end{DoxyItemize}

A layout can either be for a Control on a Device (for example, {\ttfamily Stick}), or for a Device itself (that is, anything based on \href{../api/UnityEngine.InputSystem.InputDevice.html}{\texttt{ {\ttfamily Input\+Device}}}).

The Input \doxylink{namespace_system}{System} only loads layouts when they are needed (usually, when creating a new Device). To manually load a layout, you can use \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_LoadLayout_System_String_}{\texttt{ {\ttfamily Input\+System.\+Load\+Layout}}}. This returns an \href{../api/UnityEngine.InputSystem.Layouts.InputControlLayout.html}{\texttt{ {\ttfamily Input\+Control\+Layout}}} instance, which contains the final, fully merged (that is, containing any information inherited from base layouts and/or affected by layout overrides) structure of the layout.

You can register new layouts through \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_RegisterLayout_System_String_System_String_System_Nullable_UnityEngine_InputSystem_Layouts_InputDeviceMatcher__}{\texttt{ {\ttfamily Input\+System.\+Register\+Layout}}}.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts_autotoc_md1431}{}\doxysection{\texorpdfstring{Layout formats}{Layout formats}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts_autotoc_md1431}
You can add new layouts layouts in one of three ways.


\begin{DoxyEnumerate}
\item Represented by C\# structs and classes.
\item In JSON format.
\item Built on the fly at runtime using layout builders.
\end{DoxyEnumerate}\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts_autotoc_md1432}{}\doxysubsection{\texorpdfstring{Layout from type}{Layout from type}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts_autotoc_md1432}
In its most basic form, a layout can be expressed by a C\# class derived from\+:


\begin{DoxyItemize}
\item \href{../api/UnityEngine.InputSystem.InputControl.html}{\texttt{ {\ttfamily Input\+Control}}} for a Control layout.
\item \href{../api/UnityEngine.InputSystem.InputDevice.html}{\texttt{ {\ttfamily Input\+Device}}} for a Device layout.
\end{DoxyItemize}


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ The\ InputControlLayout\ attribute\ is\ not\ strictly\ necessary\ here.}}
\DoxyCodeLine{\textcolor{comment}{//\ However,\ you\ can\ use\ it\ to\ set\ additional\ properties\ (such\ as}}
\DoxyCodeLine{\textcolor{comment}{//\ a\ custom\ display\ name\ for\ the\ layout).}}
\DoxyCodeLine{[InputControlLayout]}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keyword}{class\ }MyDevice\ :\ InputDevice}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ AxisControl\ axis\ \{\ \textcolor{keyword}{get};\ \textcolor{keyword}{private}\ \textcolor{keyword}{set};\ \}}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ ButtonControl\ button\ \{\ \textcolor{keyword}{get};\ \textcolor{keyword}{private}\ \textcolor{keyword}{set};\ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{protected}\ \textcolor{keyword}{override}\ \textcolor{keywordtype}{void}\ FinishSetup(InputDeviceBuilder\ builder)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ base.FinishSetup(builder);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ axis\ =\ builder.GetControl<AxisControl>(\textcolor{stringliteral}{"{}axis"{}});}
\DoxyCodeLine{\ \ \ \ \ \ \ \ button\ =\ builder.GetControl<ButtonControl>(\textcolor{stringliteral}{"{}button"{}});}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


You can then register the layout with \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_RegisterLayout_System_String_System_String_System_Nullable_UnityEngine_InputSystem_Layouts_InputDeviceMatcher__}{\texttt{ {\ttfamily Input\+System.\+Register\+Layout}}}. This works the same for Control and for Device layouts.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Note:\ This\ should\ generally\ be\ done\ from\ InitializeOnLoad/}}
\DoxyCodeLine{\textcolor{comment}{//\ RuntimeInitializeOnLoad\ code.}}
\DoxyCodeLine{InputSystem.RegisterLayout<MyDevice>();}

\end{DoxyCode}


When the layout is instantiated, the system looks at every field and property defined directly in the type to potentially turn it into one or more Control items.


\begin{DoxyEnumerate}
\item If the field or property is annotated with \href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html}{\texttt{ {\ttfamily Input\+Control\+Attribute}}}, the system applies the attribute\textquotesingle{}s properties to the Control item. Some special defaults apply in this case\+:
\begin{DoxyItemize}
\item If no \href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html\#UnityEngine_InputSystem_Layouts_InputControlAttribute_offset}{\texttt{ {\ttfamily offset}}} is set, and the attribute is applied to a field, \href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html\#UnityEngine_InputSystem_Layouts_InputControlAttribute_offset}{\texttt{ {\ttfamily offset}}} defaults to the offset of the field.
\item If no \href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html\#UnityEngine_InputSystem_Layouts_InputControlAttribute_name}{\texttt{ {\ttfamily name}}} is set, it defaults to the name of the property/field.
\item If no \href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html\#UnityEngine_InputSystem_Layouts_InputControlAttribute_layout}{\texttt{ {\ttfamily layout}}} is set, the system infers it from the type of the field/property.
\end{DoxyItemize}
\item If the field or property has a struct type which implements \href{../api/UnityEngine.InputSystem.LowLevel.IInputStateTypeInfo.html}{\texttt{ {\ttfamily IInput\+State\+Type\+Info}}}, the field is considered to be an embedded state struct and the system recurses into the field or property to gather Controls from it.
\item Otherwise, if the type of the field or property is based on \href{../api/UnityEngine.InputSystem.InputControl.html}{\texttt{ {\ttfamily Input\+Control}}}, the system adds a Control item similar to case 1, where the member is annotated with \href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html}{\texttt{ {\ttfamily Input\+Control\+Attribute}}}.
\end{DoxyEnumerate}\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts_autotoc_md1433}{}\doxysubsubsection{\texorpdfstring{Using a state structure}{Using a state structure}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts_autotoc_md1433}
When you implement support for a new Input Device, there\textquotesingle{}s usually an existing data format in which the Input \doxylink{namespace_system}{System} receives input for the Device. The easiest way to add support for the data format is to describe it with a C\# struct annotated with \href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html}{\texttt{ {\ttfamily Input\+Control\+Attribute}}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keyword}{struct\ }MyDeviceState\ :\ IInputStateTypeInfo}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ FourCC\ format\ =>\ \textcolor{keyword}{new}\ FourCC(\textcolor{charliteral}{'M'},\ \textcolor{charliteral}{'D'},\ \textcolor{charliteral}{'E'},\ \textcolor{charliteral}{'V'});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ [InputControl(name\ =\ \textcolor{stringliteral}{"{}button1"{}},\ layout\ =\ \textcolor{stringliteral}{"{}Button"{}},\ bit\ =\ 0)]}
\DoxyCodeLine{\ \ \ \ [InputControl(name\ =\ \textcolor{stringliteral}{"{}button2"{}},\ layout\ =\ \textcolor{stringliteral}{"{}Button"{}},\ bit\ =\ 1)]}
\DoxyCodeLine{\ \ \ \ [InputControl(name\ =\ \textcolor{stringliteral}{"{}dpad"{}},\ layout\ =\ \textcolor{stringliteral}{"{}Dpad"{}},\ bit\ =\ 2,\ sizeInBits\ =\ 4)]}
\DoxyCodeLine{\ \ \ \ [InputControl(name\ =\ \textcolor{stringliteral}{"{}dpad/up"{}},\ bit\ =\ 2)]}
\DoxyCodeLine{\ \ \ \ [InputControl(name\ =\ \textcolor{stringliteral}{"{}dpad/down"{}},\ bit\ =\ 3)]}
\DoxyCodeLine{\ \ \ \ [InputControl(name\ =\ \textcolor{stringliteral}{"{}dpad/left"{}},\ bit\ =\ 4)]}
\DoxyCodeLine{\ \ \ \ [InputControl(name\ =\ \textcolor{stringliteral}{"{}dpad/right"{}},\ bit\ =\ 5)]}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ \textcolor{keywordtype}{int}\ buttons;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ [InputControl(layout\ =\ \textcolor{stringliteral}{"{}Stick"{}})]}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ Vector2\ stick;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ [InputControl(layout\ =\ \textcolor{stringliteral}{"{}Axis"{}})]\ \textcolor{comment}{//\ Automatically\ converts\ from\ byte\ to\ float.}}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ \textcolor{keywordtype}{byte}\ trigger;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ The\ Device\ must\ be\ directed\ to\ the\ state\ struct\ we\ have\ created.}}
\DoxyCodeLine{[InputControlLayout(stateType\ =\ typeof(MyDeviceState)]}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keyword}{class}\ MyDevice\ :\ InputDevice}
\DoxyCodeLine{\{}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts_autotoc_md1434}{}\doxysubsection{\texorpdfstring{Layout from JSON}{Layout from JSON}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts_autotoc_md1434}
You can also create a layout from a JSON string that contains the same information. This is mostly useful if you want to be able to store and transfer layout information separate from your code -\/ for instance, if you want to be able to add support for new Devices dynamically without making a new build of your application. You can use \href{../api/UnityEngine.InputSystem.Layouts.InputControlLayout.html\#UnityEngine_InputSystem_Layouts_InputControlLayout_ToJson}{\texttt{ {\ttfamily Input\+Control\+Layout.\+To\+Json()}}} and \href{../api/UnityEngine.InputSystem.Layouts.InputControlLayout.html\#UnityEngine_InputSystem_Layouts_InputControlLayout_FromJson_System_String_}{\texttt{ {\ttfamily Input\+Control\+Layout.\+From\+Json()}}} to convert layouts to and from the format.

The same layout as above looks like this in JSON format\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ "{}name"{}:\ "{}MyDevice"{},}
\DoxyCodeLine{\ \ \ \ "{}format"{}:\ "{}MDEV"{},}
\DoxyCodeLine{\ \ \ \ "{}controls"{}:\ [}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}name"{}:\ "{}button1"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}layout"{}:\ "{}Button"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}offset"{}:\ 0,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}bit"{}:\ 0,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}name"{}:\ "{}button2"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}layout"{}:\ "{}Button"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}offset"{}:\ 0,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}bit"{}:\ 1,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}name"{}:\ "{}dpad"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}layout"{}:\ "{}Dpad"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}offset"{}:\ 0,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}bit"{}:\ 2,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}sizeInBits"{}:\ 4,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}name"{}:\ "{}dpad/up"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}offset"{}:\ -\/1,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}bit"{}:\ 2,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}name"{}:\ "{}dpad/down"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}offset"{}:\ -\/1,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}bit"{}:\ 3,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}name"{}:\ "{}dpad/left"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}offset"{}:\ -\/1,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}bit"{}:\ 4,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}name"{}:\ "{}dpad/right"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}offset"{}:\ -\/1,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}bit"{}:\ 5,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}name"{}:\ "{}stick"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}layout"{}:\ "{}Stick"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}offset"{}:\ 4,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}format"{}:\ "{}VEC2"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}name"{}:\ "{}trigger"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}layout"{}:\ "{}Axis"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}offset"{}:\ 12,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ "{}format"{}:\ "{}BYTE"{},}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ ]}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts_autotoc_md1435}{}\doxysubsection{\texorpdfstring{Generated layouts}{Generated layouts}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts_autotoc_md1435}
Finally, the Input \doxylink{namespace_system}{System} can also build layouts on the fly in code. This is useful for Device interfaces such as \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_h_i_d}{HID}{0} that supply descriptive information for each Device.

To build layouts dynamically in code, you can use the \href{../api/UnityEngine.InputSystem.Layouts.InputControlLayout.Builder.html}{\texttt{ {\ttfamily Input\+Control\+Layout.\+Builder}}} API.

Here\textquotesingle{}s the same layout from the previous examples constructed programmatically\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ builder\ =\ new\ InputControlLayout.Builder()}
\DoxyCodeLine{\ \ \ \ .WithName("{}MyDevice"{})}
\DoxyCodeLine{\ \ \ \ .WithFormat("{}MDEV"{});}
\DoxyCodeLine{}
\DoxyCodeLine{builder.AddControl("{}button1"{})}
\DoxyCodeLine{\ \ \ \ .WithLayout("{}Button"{})}
\DoxyCodeLine{\ \ \ \ .WithByteOffset(0)}
\DoxyCodeLine{\ \ \ \ .WithBitOffset(0);}
\DoxyCodeLine{}
\DoxyCodeLine{builder.AddControl("{}button2"{})}
\DoxyCodeLine{\ \ \ \ .WithLayout("{}Button"{})}
\DoxyCodeLine{\ \ \ \ .WithByteOffset(0)}
\DoxyCodeLine{\ \ \ \ .WithBitOffset(1);}
\DoxyCodeLine{}
\DoxyCodeLine{builder.AddControl("{}dpad"{})}
\DoxyCodeLine{\ \ \ \ .WithLayout("{}Dpad"{})}
\DoxyCodeLine{\ \ \ \ .WithByteOffset(0)}
\DoxyCodeLine{\ \ \ \ .WithBitOffset(2)}
\DoxyCodeLine{\ \ \ \ .WithSizeInBits(4);}
\DoxyCodeLine{}
\DoxyCodeLine{builder.AddControl("{}dpad/up"{})}
\DoxyCodeLine{\ \ \ \ .WithByteOffset(-\/1)}
\DoxyCodeLine{\ \ \ \ .WithBitOffset(2);}
\DoxyCodeLine{}
\DoxyCodeLine{builder.AddControl("{}dpad/down"{})}
\DoxyCodeLine{\ \ \ \ .WithByteOffset(-\/1)}
\DoxyCodeLine{\ \ \ \ .WithBitOffset(3);}
\DoxyCodeLine{}
\DoxyCodeLine{builder.AddControl("{}dpad/left"{})}
\DoxyCodeLine{\ \ \ \ .WithByteOffset(-\/1)}
\DoxyCodeLine{\ \ \ \ .WithBitOffset(4);}
\DoxyCodeLine{}
\DoxyCodeLine{builder.AddControl("{}dpad/right"{})}
\DoxyCodeLine{\ \ \ \ .WithByteOffset(-\/1)}
\DoxyCodeLine{\ \ \ \ .WithBitOffset(5);}
\DoxyCodeLine{}
\DoxyCodeLine{builder.AddControl("{}stick"{})}
\DoxyCodeLine{\ \ \ \ .WithLayout("{}Stick"{})}
\DoxyCodeLine{\ \ \ \ .WithByteOffset(4)}
\DoxyCodeLine{\ \ \ \ .WithFormat("{}VEC2"{});}
\DoxyCodeLine{}
\DoxyCodeLine{builder.AddControl("{}trigger"{})}
\DoxyCodeLine{\ \ \ \ .WithLayout("{}Axis"{})}
\DoxyCodeLine{\ \ \ \ .WithByteOffset(12)}
\DoxyCodeLine{\ \ \ \ .WithFormat("{}BYTE"{});}
\DoxyCodeLine{}
\DoxyCodeLine{var\ layout\ =\ builder.Build();}

\end{DoxyCode}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts_autotoc_md1436}{}\doxysection{\texorpdfstring{Layout inheritance}{Layout inheritance}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts_autotoc_md1436}
You can derive a layout from an existing layout. This process is based on merging the information from the derived layout on top of the information that the base layout contains.


\begin{DoxyItemize}
\item For layouts defined as types, the base layout is the layout of the base type (if any).
\item For layouts defined in JSON, you can specify the base layout in the {\ttfamily extends} property of the root node.
\item For layouts created in code using \href{../api/UnityEngine.InputSystem.Layouts.InputControlLayout.Builder.html}{\texttt{ {\ttfamily Input\+Control\+Layout.\+Builder}}}, you can specify a base layout using \href{../api/UnityEngine.InputSystem.Layouts.InputControlLayout.Builder.html\#UnityEngine_InputSystem_Layouts_InputControlLayout_Builder_Extend_System_String_}{\texttt{ {\ttfamily Input\+Control\+Layout.\+Builder.\+Extend()}}}.
\end{DoxyItemize}\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts_autotoc_md1437}{}\doxysection{\texorpdfstring{Control items}{Control items}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts_autotoc_md1437}
Each layout is comprised of zero or more Control items. Each item either describes a new Control, or modifies the properties of an existing Control. The latter can also reach down into the hierarchy and modify properties of a Control added implicitly as a child by another item.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Add\ a\ dpad\ Control.}}
\DoxyCodeLine{[InputControl(layout\ =\ \textcolor{stringliteral}{"{}Dpad"{}})]}
\DoxyCodeLine{\textcolor{comment}{//\ And\ now\ modify\ the\ properties\ of\ the\ "{}up"{}\ Control\ that\ was\ added\ by\ the}}
\DoxyCodeLine{\textcolor{comment}{//\ "{}Dpad"{}\ layout\ above.}}
\DoxyCodeLine{[InputControl(name\ =\ \textcolor{stringliteral}{"{}dpad/up"{}},\ displayName\ =\ \textcolor{stringliteral}{"{}DPADUP"{}})]}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keywordtype}{int}\ buttons;}

\end{DoxyCode}


The following table details the properties that a Control item can have. These can be set as properties on \href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html}{\texttt{ {\ttfamily Input\+Control\+Attribute}}}, as properties on the Control in JSON, or through methods on \href{../api/UnityEngine.InputSystem.Layouts.InputControlLayout.Builder.ControlBuilder.html}{\texttt{ {\ttfamily Input\+Control\+Layout.\+Builder.\+Control\+Builder}}}.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Property   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Property   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-2}
\endhead
\href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html\#UnityEngine_InputSystem_Layouts_InputControlAttribute_name}{\texttt{ {\ttfamily name}}}   &Name of the Control.~\newline
By default, this is the name of the field/property that \href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html}{\texttt{ {\ttfamily Input\+Control\+Attribute}}} is applied to.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html\#UnityEngine_InputSystem_Layouts_InputControlAttribute_displayName}{\texttt{ {\ttfamily display\+Name}}}   &Display name of the Control (for use in UI strings).    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html\#UnityEngine_InputSystem_Layouts_InputControlAttribute_shortDisplayName}{\texttt{ {\ttfamily short\+Display\+Name}}}   &Short display name of the Control (for use in UI strings).    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html\#UnityEngine_InputSystem_Layouts_InputControlAttribute_layout}{\texttt{ {\ttfamily layout}}}   &Layout to use for the Control.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html\#UnityEngine_InputSystem_Layouts_InputControlAttribute_variants}{\texttt{ {\ttfamily variants}}}   &Variants of the Control.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html\#UnityEngine_InputSystem_Layouts_InputControlAttribute_aliases}{\texttt{ {\ttfamily aliases}}}   &Aliases for the Control. These are alternative names the Control can be referred by.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html\#UnityEngine_InputSystem_Layouts_InputControlAttribute_usages}{\texttt{ {\ttfamily usages}}}   &\href{Controls.md\#control-usages}{\texttt{ Usages}} of the Control.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html\#UnityEngine_InputSystem_Layouts_InputControlAttribute_offset}{\texttt{ {\ttfamily offset}}}   &The byte offset at which the state for the Control is found.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html\#UnityEngine_InputSystem_Layouts_InputControlAttribute_bit}{\texttt{ {\ttfamily bit}}}   &The bit offset at which the state of the Control is found within its byte.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html\#UnityEngine_InputSystem_Layouts_InputControlAttribute_sizeInBits}{\texttt{ {\ttfamily size\+In\+Bits}}}   &The total size of the Control\textquotesingle{}s state, in bits.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html\#UnityEngine_InputSystem_Layouts_InputControlAttribute_arraySize}{\texttt{ {\ttfamily array\+Size}}}   &If this is set to a non-\/zero value, the system will create an array of Controls of this size.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html\#UnityEngine_InputSystem_Layouts_InputControlAttribute_parameters}{\texttt{ {\ttfamily parameters}}}   &Any parameters to be passed to the Control. The system will apply these to any fields the Control type might have, such as \href{../api/UnityEngine.InputSystem.Controls.AxisControl.html\#UnityEngine_InputSystem_Controls_AxisControl_scaleFactor}{\texttt{ {\ttfamily Axis\+Control.\+scale\+Factor}}}.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html\#UnityEngine_InputSystem_Layouts_InputControlAttribute_processors}{\texttt{ {\ttfamily processors}}}   &\doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_processors}{Processors}{0} to apply to the Control.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html\#UnityEngine_InputSystem_Layouts_InputControlAttribute_noisy}{\texttt{ {\ttfamily noisy}}}   &Whether the Control is to be considered \href{Controls.md\#noisy-controls}{\texttt{ noisy}}.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html\#UnityEngine_InputSystem_Layouts_InputControlAttribute_synthetic}{\texttt{ {\ttfamily synthetic}}}   &Whether the Control is to be considered \href{Controls.md\#synthetic-controls}{\texttt{ synthetic}}.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html\#UnityEngine_InputSystem_Layouts_InputControlAttribute_defaultState}{\texttt{ {\ttfamily default\+State}}}   &Default initial value of the state {\bfseries{memory}} Control.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html\#UnityEngine_InputSystem_Layouts_InputControlAttribute_useStateFrom}{\texttt{ {\ttfamily use\+State\+From}}}   &For \href{Controls.md\#synthetic-controls}{\texttt{ synthetic}} Controls, used to synthesize Control state.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html\#UnityEngine_InputSystem_Layouts_InputControlAttribute_minValue}{\texttt{ {\ttfamily min\+Value}}}   &The minimum value the Control can report. Used for evaluating \href{Controls.md\#control-actuation}{\texttt{ Control magnitude}}.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html\#UnityEngine_InputSystem_Layouts_InputControlAttribute_maxValue}{\texttt{ {\ttfamily max\+Value}}}   &The maximum value the Control can report. Used for evaluating \href{Controls.md\#control-actuation}{\texttt{ Control magnitude}}.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html\#UnityEngine_InputSystem_Layouts_InputControlAttribute_dontReset}{\texttt{ {\ttfamily dont\+Reset}}}   &When a device \href{Devices.md\#device-resets}{\texttt{ "{}soft"{} reset}} is performed, the state of this control will not be reset. This is useful for controls such as pointer positions which should not go to {\ttfamily (0,0)} on a reset. When a "{}hard"{} reset is performed, the control will still be reset to its default value.   \\\cline{1-2}
\end{longtabu}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts_autotoc_md1438}{}\doxysection{\texorpdfstring{Layout overrides}{Layout overrides}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts_autotoc_md1438}
You can non-\/destructively change aspects of an existing layout using layout overrides. You can call \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_RegisterLayoutOverride_System_String_System_String_}{\texttt{ {\ttfamily Input\+System.\+Register\+Layout\+Override}}} to register a layout as an override of its base layout. The system then adds any property present in the override to the base layout or to existing properties.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Add\ an\ extra\ Control\ to\ the\ "{}Mouse"{}\ layout}}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keywordtype}{string}\ json\ =\ \textcolor{stringliteral}{@"{}}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ \{}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ \ \ \ \ "{}"{}name"{}"{}\ :\ "{}"{}Overrides"{}"{},}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ \ \ \ \ "{}"{}extend"{}"{}\ :\ "{}"{}Mouse"{}"{},}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ \ \ \ \ "{}"{}controls"{}"{}\ :\ [}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \{\ "{}"{}name"{}"{}\ :\ "{}"{}extraControl"{}"{},\ "{}"{}layout"{}"{}\ :\ "{}"{}Button"{}"{}\ \}}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ \ \ \ \ ]}}
\DoxyCodeLine{\textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{\textcolor{stringliteral}{"{}};}
\DoxyCodeLine{}
\DoxyCodeLine{InputSystem.RegisterLayoutOverride(json);}

\end{DoxyCode}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts_autotoc_md1439}{}\doxysection{\texorpdfstring{Precompiled layouts}{Precompiled layouts}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts_autotoc_md1439}
Building a device at runtime from an \href{../api/UnityEngine.InputSystem.Layouts.InputControlLayout.html}{\texttt{ {\ttfamily Input\+Control\+Layout}}} is a slow process. The layout instance itself has to be built (which might involve reflection) and then interpreted in order to put the final \href{../api/UnityEngine.InputSystem.InputDevice.html}{\texttt{ {\ttfamily Input\+Device}}} instance together. This process usually involves the loading of multiple \href{../api/UnityEngine.InputSystem.Layouts.InputControlLayout.html}{\texttt{ {\ttfamily Input\+Control\+Layout}}} instances, each of which might be the result of merging multiple layouts together (if the layout involves inheritance or overrides).

You can speed up this process up by "{}baking"{} the final form of a layout into a "{}precompiled layout"{}. A precompiled layout is generated C\# code that, when run, will build the corresponding device without relying on loading and interpreting an \href{../api/UnityEngine.InputSystem.Layouts.InputControlLayout.html}{\texttt{ {\ttfamily Input\+Control\+Layout}}}. Aside from running faster, this will also create far less garbage and will not involve C\# reflection (which generally causes runtime overhead by inflating the number of objects internally kept by the C\# runtime).

\texorpdfstring{$>$}{>}{\bfseries{NOTE}}\+: Precompiled layouts must be device layouts. It is not possible to precompile the layout for an \href{../api/UnityEngine.InputSystem.InputControl.html}{\texttt{ {\ttfamily Input\+Control}}}.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts_autotoc_md1440}{}\doxysubsection{\texorpdfstring{Creating a precompiled layout}{Creating a precompiled layout}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts_autotoc_md1440}
The first step in setting up a precompiled layout is to generate it. To do so, open the \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_debugging}{Input Debugger}{0}, navigate to the layout you want to precompile within the {\bfseries{Layouts}} branch, right-\/click it, and select {\bfseries{Generate Precompiled Layout}}.



\doxylink{namespace_unity}{Unity} will ask you where to store the generated code. Pick a directory in your project, enter a file name, and click {\bfseries{Save}}.

Once generated, you can register the precompiled layout with the Input \doxylink{namespace_system}{System} using \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_RegisterPrecompiledLayout__1_System_String_}{\texttt{ {\ttfamily Input\+System.\+Register\+Precompiled\+Layout}}}. The method expects a string argument containing metadata for the precompiled layout. This string is automatically emitted as a {\ttfamily const} inside the generated class.


\begin{DoxyCode}{0}
\DoxyCodeLine{InputSystem.RegisterPrecompiledLayout<MyPrecompiledDevice>(MyPrecompiledDevice.metadata);}

\end{DoxyCode}


\texorpdfstring{$>$}{>}{\bfseries{IMPORTANT}}\+: It is very important that this method is called with all relevant layout registrations being in the same state as at the time the layout was precompiled. There is no internal check whether the precompiled layout will still generate an identical result to the non-\/precompiled version.

Once registered, a precompiled layout is automatically used whenever the layout that the precompiled layout is based on is instantiated.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Let's\ assume\ you\ have\ a\ custom\ device\ class.}}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keyword}{class\ }MyDevice\ :\ InputDevice}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Setters\ for\ your\ control\ getters\ need\ to\ have\ at\ least\ \`{}protected`}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ or\ \`{}internal`\ access\ so\ the\ precompiled\ version\ can\ use\ them.}}
\DoxyCodeLine{\ \ \ \ [InputControl]}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ ButtonControl\ button\ \{\ \textcolor{keyword}{get};\ \textcolor{keyword}{protected}\ \textcolor{keyword}{set};\ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ This\ method\ will\ *NOT*\ be\ invoked\ by\ the\ precompiled\ version.\ Instead,\ all\ the\ lookups}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ performed\ here\ will\ get\ hardcoded\ into\ the\ generated\ C\#\ code.}}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{protected}\ \textcolor{keyword}{override}\ \textcolor{keywordtype}{void}\ FinishSetup()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ base.FinishSetup();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ button\ =\ GetChildControl<ButtonControl>(\textcolor{stringliteral}{"{}button1"{}});}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ You\ register\ the\ device\ as\ a\ layout\ somewhere\ during\ startup.}}
\DoxyCodeLine{InputSystem.RegisterLayout<MyDevice>();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ And\ you\ register\ a\ precompiled\ version\ of\ it\ then\ as\ well.}}
\DoxyCodeLine{InputSystem.RegisterPrecompiledLayout<PrecompiledMyDevice>(PrecompiledMyDevice.metadata);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Then\ the\ following\ will\ implicitly\ use\ the\ precompiled\ version.}}
\DoxyCodeLine{InputSystem.AddDevice<MyDevice>();}

\end{DoxyCode}


A precompiled layout will automatically be unregistered in the following cases\+:


\begin{DoxyItemize}
\item A layout override is applied to one of the layouts used by the precompiled Device. This also extends to \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_controls}{controls}{0} used by the Device.
\item A layout with the same name as one of the layouts used by the precompiled Device is registered (which replaces the layout already registered under the name).
\item A \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_processors}{processor}{0} is registered that replaces a processor used by the precompiled Device.
\end{DoxyItemize}

This causes the Input \doxylink{namespace_system}{System} to fall back to the non-\/precompiled version of the layout. Note also that a precompiled layout will not be used for layouts derived from the layout the precompiled version is based on. In the example above, if someone derives a new layout from {\ttfamily My\+Device}, the precompiled version is unaffected (it will not be unregistered) but is also not used for the newly created type of device.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Let's\ constinue\ from\ the\ example\ above\ and\ assume\ that\ sometime}}
\DoxyCodeLine{\textcolor{comment}{//\ later,\ someone\ replaces\ the\ built-\/in\ button\ with\ an\ extended\ version.}}
\DoxyCodeLine{InputSystem.RegisterLayout<ExtendedButtonControl>(\textcolor{stringliteral}{"{}Button"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ PrecompiledMyDevice\ has\ implicitly\ been\ removed\ now,\ because\ the\ ButtonControl\ it\ uses}}
\DoxyCodeLine{\textcolor{comment}{//\ has\ now\ been\ replaced\ with\ ExtendedButtonControl.}}

\end{DoxyCode}


If needed, you can add {\ttfamily \#if} checks to the generated code, if needed. The code generator will scan the start of an existing file for a line starting with {\ttfamily \#if} and, if found, preserve it in newly generated code and generate a corresponding {\ttfamily \#endif} at the end of the file. Similarly, you can change the generated class from {\ttfamily public} to {\ttfamily internal} and the modifier will be preserved when regenerating the class. Finally, you can also modify the namespace in the generated file with the change being preserved.

The generated class is marked as {\ttfamily partial}, which means you can add additional overloads and other code by having a parallel, {\ttfamily partial} class definition.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ The\ next\ line\ will\ be\ preserved\ when\ regenerating\ the\ precompiled\ layout.\ A}}
\DoxyCodeLine{\textcolor{comment}{//\ corresponding\ \#endif\ will\ be\ emitted\ at\ the\ end\ of\ the\ file.}}
\DoxyCodeLine{\textcolor{preprocessor}{\#if\ UNITY\_EDITOR\ ||\ UNITY\_STANDALONE}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ If\ you\ change\ the\ namespace\ to\ a\ different\ one,\ the\ name\ of\ the\ namespace\ will\ be}}
\DoxyCodeLine{\textcolor{comment}{//\ preserved\ when\ you\ regenerate\ the\ precompiled\ layout.}}
\DoxyCodeLine{namepace\ MyNamespace}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ If\ you\ change\ \`{}public`\ to\ \`{}internal`,\ the\ change\ will\ be\ preserved}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ when\ regenerating\ the\ precompiled\ layout.}}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ \textcolor{keyword}{partial\ class\ }PrecompiledMyDevice\ :\ MyDevice}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//...}}

\end{DoxyCode}


The namespace of the generated layout will correspond to the 