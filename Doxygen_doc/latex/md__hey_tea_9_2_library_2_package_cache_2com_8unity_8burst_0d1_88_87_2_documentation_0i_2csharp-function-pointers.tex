\chapter{Function pointers}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2csharp-function-pointers}{}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2csharp-function-pointers}\index{Function pointers@{Function pointers}}
\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2csharp-function-pointers_autotoc_md342}%
\Hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2csharp-function-pointers_autotoc_md342}%
 To work with dynamic functions that process data based on other data states, use \href{xref:Unity.Burst.FunctionPointer`1}{\texttt{ {\ttfamily Function\+Pointer\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}}}}. Because \doxylink{namespace_burst}{Burst} treats delegates as managed objects, you can\textquotesingle{}t use \href{https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/}{\texttt{ C\# delegates}} to work with dynamic functions.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2csharp-function-pointers_autotoc_md343}{}\doxysection{\texorpdfstring{Support details}{Support details}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2csharp-function-pointers_autotoc_md343}
Function pointers don\textquotesingle{}t support generic delegates. Also, avoid wrapping \href{xref:Unity.Burst.BurstCompiler.CompileFunctionPointer``1(``0)}{\texttt{ {\ttfamily Burst\+Compiler.\+Compile\+Function\+Pointer\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}}}} within another open generic method. If you do this, \doxylink{namespace_burst}{Burst} can\textquotesingle{}t apply required attributes to the delegate, perform additional safety analysis, or perform potential optimizations.

Argument and return types are subject to the same restrictions as {\ttfamily Dll\+Import} and internal calls. For more information, see the documentation on \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2csharp-burst-intrinsics-dllimport}{Dll\+Import and internal calls}{0}.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2csharp-function-pointers_autotoc_md344}{}\doxysubsection{\texorpdfstring{Interoperability with IL2\+CPP}{Interoperability with IL2\+CPP}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2csharp-function-pointers_autotoc_md344}
Interoperability of function pointers with IL2\+CPP requires {\ttfamily System.\+Runtime.\+Interop\+Services.\+Unmanaged\+Function\+Pointer\+Attribute} on the delegate. Set the calling convention to {\ttfamily Calling\+Convention.\+Cdecl}. \doxylink{namespace_burst}{Burst} automatically adds this attribute to delegates that are used with \href{xref:Unity.Burst.BurstCompiler.CompileFunctionPointer``1(``0)}{\texttt{ {\ttfamily Burst\+Compiler.\+Compile\+Function\+Pointer\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}}}}.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2csharp-function-pointers_autotoc_md345}{}\doxysection{\texorpdfstring{Using function pointers}{Using function pointers}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2csharp-function-pointers_autotoc_md345}
To use function pointers, identify the static functions that you want \doxylink{namespace_burst}{Burst} to compile and do the following\+:


\begin{DoxyEnumerate}
\item Add a {\ttfamily \mbox{[}Burst\+Compile\mbox{]}} attribute to these functions
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Add a {\ttfamily \mbox{[}Burst\+Compile\mbox{]}} attribute to the containing type. This helps the \doxylink{namespace_burst}{Burst} compiler find the static methods that have {\ttfamily \mbox{[}Burst\+Compile\mbox{]}} attribute
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Declare a delegate to create the "{}interface"{} of these functions
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Add a {\ttfamily \mbox{[}Mono\+PInvoke\+Callback\+Attribute\mbox{]}} attribute to the functions. You need to add this so that IL2\+CPP works with these functions. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#}}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Instruct\ Burst\ to\ look\ for\ static\ methods\ with\ [BurstCompile]\ attribute}}
\DoxyCodeLine{\ \ \ [BurstCompile]}
\DoxyCodeLine{\ \ \ \textcolor{keyword}{class\ }EnclosingType\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ [BurstCompile]}
\DoxyCodeLine{\ \ \ \ \ \ \ [MonoPInvokeCallback(typeof(Process2FloatsDelegate))]}
\DoxyCodeLine{\ \ \ \ \ \ \ \textcolor{keyword}{public}\ \textcolor{keyword}{static}\ \textcolor{keywordtype}{float}\ MultiplyFloat(\textcolor{keywordtype}{float}\ a,\ \textcolor{keywordtype}{float}\ b)\ =>\ a\ *\ b;}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \ \ \ \ [BurstCompile]}
\DoxyCodeLine{\ \ \ \ \ \ \ [MonoPInvokeCallback(typeof(Process2FloatsDelegate))]}
\DoxyCodeLine{\ \ \ \ \ \ \ \textcolor{keyword}{public}\ \textcolor{keyword}{static}\ \textcolor{keywordtype}{float}\ AddFloat(\textcolor{keywordtype}{float}\ a,\ \textcolor{keywordtype}{float}\ b)\ =>\ a\ +\ b;}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \ \ \ \ \textcolor{comment}{//\ A\ common\ interface\ for\ both\ MultiplyFloat\ and\ AddFloat\ methods}}
\DoxyCodeLine{\ \ \ \ \ \ \ \textcolor{keyword}{public}\ delegate\ \textcolor{keywordtype}{float}\ Process2FloatsDelegate(\textcolor{keywordtype}{float}\ a,\ \textcolor{keywordtype}{float}\ b);}
\DoxyCodeLine{\ \ \ \}}

\end{DoxyCode}

\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Compile these function pointers from regular C\# code\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#}}
\DoxyCodeLine{\ \ \ \ \ \ \ \textcolor{comment}{//\ Contains\ a\ compiled\ version\ of\ MultiplyFloat\ with\ Burst}}
\DoxyCodeLine{\ \ \ \ \ \ \ FunctionPointer<Process2FloatsDelegate>\ mulFunctionPointer\ =\ \mbox{\hyperlink{class_burst_compiler}{BurstCompiler}}.CompileFunctionPointer<Process2FloatsDelegate>(MultiplyFloat);}
\DoxyCodeLine{\ \ \ }
\DoxyCodeLine{\ \ \ \ \ \ \ \textcolor{comment}{//\ Contains\ a\ compiled\ version\ of\ AddFloat\ with\ Burst}}
\DoxyCodeLine{\ \ \ \ \ \ \ FunctionPointer<Process2FloatsDelegate>\ addFunctionPointer\ =\ \mbox{\hyperlink{class_burst_compiler}{BurstCompiler}}.\ \ \ \ CompileFunctionPointer<Process2FloatsDelegate>(AddFloat);}

\end{DoxyCode}

\end{DoxyEnumerate}\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2csharp-function-pointers_autotoc_md346}{}\doxysubsection{\texorpdfstring{Using function pointers in a job}{Using function pointers in a job}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2csharp-function-pointers_autotoc_md346}
To use the function pointers directly from a job, pass them to the job struct\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#}}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Invoke\ the\ function\ pointers\ from\ HPC\#\ jobs}}
\DoxyCodeLine{\ \ \ var\ resultMul\ =\ mulFunctionPointer.Invoke(1.0f,\ 2.0f);}
\DoxyCodeLine{\ \ \ var\ resultAdd\ =\ addFunctionPointer.Invoke(1.0f,\ 2.0f);}

\end{DoxyCode}


\doxylink{namespace_burst}{Burst} compiles function pointers asynchronously for jobs by default. To force a synchronous compilation of function pointers use {\ttfamily \mbox{[}Burst\+Compile(Synchronous\+Compilation = true)\mbox{]}}.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2csharp-function-pointers_autotoc_md347}{}\doxysubsection{\texorpdfstring{Using function pointers in C\# code}{Using function pointers in C\# code}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2csharp-function-pointers_autotoc_md347}
To use these function pointers from regular C\# code, cache the {\ttfamily Function\+Pointer\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}.Invoke} property (which is the delegate instance) to a static field to get the best performance\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#}}
\DoxyCodeLine{\ \ \ \textcolor{keyword}{private}\ readonly\ \textcolor{keyword}{static}\ Process2FloatsDelegate\ mulFunctionPointerInvoke\ =\ \mbox{\hyperlink{class_burst_compiler}{BurstCompiler}}.CompileFunctionPointer<Process2FloatsDelegate>(MultiplyFloat).Invoke;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \textcolor{comment}{//\ Invoke\ the\ delegate\ from\ C\#}}
\DoxyCodeLine{\ \ \ var\ resultMul\ =\ mulFunctionPointerInvoke(1.0f,\ 2.0f);}

\end{DoxyCode}


Using Burst-\/compiled function pointers from C\# might be slower than their pure C\# version counterparts if the function is too small compared to the overhead of \href{https://docs.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke}{\texttt{ {\ttfamily P/\+Invoke}}} interop.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2csharp-function-pointers_autotoc_md348}{}\doxysection{\texorpdfstring{Performance considerations}{Performance considerations}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2csharp-function-pointers_autotoc_md348}
Where possible, you use a job over a function pointer to run \doxylink{namespace_burst}{Burst} compiled code, because jobs are more optimal. \doxylink{namespace_burst}{Burst} provides better aliasing calculations for jobs because the job safety system has more optimizations by default.

You also can\textquotesingle{}t pass most of the {\ttfamily \mbox{[}Native\+Container\mbox{]}} structs like {\ttfamily Native\+Array} directly to function pointers and must use a job struct to do so. Native container structs contain managed objects for safety checks that the \doxylink{namespace_burst}{Burst} compiler can work around when compiling jobs, but not for function pointers.

The following example shows a bad example of how to use function pointers in \doxylink{namespace_burst}{Burst}. The function pointer computes {\ttfamily math.\+sqrt} from an input pointer and stores it to an output pointer. {\ttfamily My\+Job} feeds this function pointer sources from two {\ttfamily Native\+Array}s which isn\textquotesingle{}t optimal\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{[BurstCompile]}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keyword}{class\ }MyFunctionPointers}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ unsafe\ delegate\ \textcolor{keywordtype}{void}\ MyFunctionPointerDelegate(\textcolor{keywordtype}{float}*\ input,\ \textcolor{keywordtype}{float}*\ output);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ [BurstCompile]}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ \textcolor{keyword}{static}\ unsafe\ \textcolor{keywordtype}{void}\ MyFunctionPointer(\textcolor{keywordtype}{float}*\ input,\ \textcolor{keywordtype}{float}*\ output)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ *output\ =\ math.sqrt(*input);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{[BurstCompile]}
\DoxyCodeLine{\textcolor{keyword}{struct\ }MyJob\ :\ IJobParallelFor}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \ \textcolor{keyword}{public}\ FunctionPointer<MyFunctionPointers.MyFunctionPointerDelegate>\ FunctionPointer;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ [\mbox{\hyperlink{namespace_unity_editor_1_1_timeline_af9aefa8b1ec710da91fbc7bdf0bcafbca131fb182a881796e7606ed6da27f1197}{ReadOnly}}]\ \textcolor{keyword}{public}\ NativeArray<float>\ Input;}
\DoxyCodeLine{\ \ \ \ [WriteOnly]\ \textcolor{keyword}{public}\ NativeArray<float>\ Output;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ unsafe\ \textcolor{keywordtype}{void}\ Execute(\textcolor{keywordtype}{int}\ index)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ var\ inputPtr\ =\ (\textcolor{keywordtype}{float}*)Input.GetUnsafeReadOnlyPtr();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ var\ outputPtr\ =\ (\textcolor{keywordtype}{float}*)Output.GetUnsafePtr();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ FunctionPointer.Invoke(inputPtr\ +\ index,\ outputPtr\ +\ index);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


This example isn\textquotesingle{}t optimal for the following reasons\+:


\begin{DoxyItemize}
\item \doxylink{namespace_burst}{Burst} can\textquotesingle{}t vectorize the function pointer because it\textquotesingle{}s being fed a single scalar element. This means that 4-\/8x performance is lost from a lack of vectorization.
\item The {\ttfamily My\+Job} knows that the {\ttfamily Input} and {\ttfamily Output} native arrays can\textquotesingle{}t alias, but this information isn\textquotesingle{}t communicated to the function pointer.
\item There is a non-\/zero overhead to constantly branching to a function pointer somewhere else in memory.
\end{DoxyItemize}

To use a function pointer in an optimal way, always process batches of data in the function pointer, like so\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{[BurstCompile]}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keyword}{class\ }MyFunctionPointers}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ unsafe\ delegate\ \textcolor{keywordtype}{void}\ MyFunctionPointerDelegate(\textcolor{keywordtype}{int}\ count,\ \textcolor{keywordtype}{float}*\ input,\ \textcolor{keywordtype}{float}*\ output);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ [BurstCompile]}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ \textcolor{keyword}{static}\ unsafe\ \textcolor{keywordtype}{void}\ MyFunctionPointer(\textcolor{keywordtype}{int}\ count,\ \textcolor{keywordtype}{float}*\ input,\ \textcolor{keywordtype}{float}*\ output)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ i\ =\ 0;\ i\ <\ count;\ i++)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ output[i]\ =\ math.sqrt(input[i]);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{[BurstCompile]}
\DoxyCodeLine{\textcolor{keyword}{struct\ }MyJob\ :\ IJobParallelForBatch}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \ \textcolor{keyword}{public}\ FunctionPointer<MyFunctionPointers.MyFunctionPointerDelegate>\ FunctionPointer;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ [\mbox{\hyperlink{namespace_unity_editor_1_1_timeline_af9aefa8b1ec710da91fbc7bdf0bcafbca131fb182a881796e7606ed6da27f1197}{ReadOnly}}]\ \textcolor{keyword}{public}\ NativeArray<float>\ Input;}
\DoxyCodeLine{\ \ \ \ [WriteOnly]\ \textcolor{keyword}{public}\ NativeArray<float>\ Output;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ unsafe\ \textcolor{keywordtype}{void}\ Execute(\textcolor{keywordtype}{int}\ index,\ \textcolor{keywordtype}{int}\ count)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ var\ inputPtr\ =\ (\textcolor{keywordtype}{float}*)Input.GetUnsafeReadOnlyPtr()\ +\ index;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ var\ outputPtr\ =\ (\textcolor{keywordtype}{float}*)Output.GetUnsafePtr()\ +\ index;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ FunctionPointer.Invoke(count,\ inputPtr,\ outputPtr);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


Thee modified {\ttfamily My\+Function\+Pointer} takes a {\ttfamily count} of elements to process, and loops over the {\ttfamily input} and {\ttfamily output} pointers to do a lot of calculations. The {\ttfamily My\+Job} becomes an {\ttfamily IJob\+Parallel\+For\+Batch}, and the {\ttfamily count} is passed directly into the function pointer. This is better for performance because of the following reasons\+:


\begin{DoxyItemize}
\item \doxylink{namespace_burst}{Burst} vectorizes the {\ttfamily My\+Function\+Pointer} call.
\item Because \doxylink{namespace_burst}{Burst} processes {\ttfamily count} items per function pointer, any overhead of calling the function pointer is reduced by {\ttfamily count} times. For example, if you run a batch of 128, the function pointer overhead is 1/128th per {\ttfamily index} of what it was previously.
\item Batching results in a 1.\+53x performance gain over not batching.
\end{DoxyItemize}

However, to get the best possible performance, use a job. This gives \doxylink{namespace_burst}{Burst} the most visibility over what you want it to do, and the most opportunities to optimize\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{[BurstCompile]}
\DoxyCodeLine{\textcolor{keyword}{struct\ }MyJob\ :\ IJobParallelFor}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ [\mbox{\hyperlink{namespace_unity_editor_1_1_timeline_af9aefa8b1ec710da91fbc7bdf0bcafbca131fb182a881796e7606ed6da27f1197}{ReadOnly}}]\ \textcolor{keyword}{public}\ NativeArray<float>\ Input;}
\DoxyCodeLine{\ \ \ \ [WriteOnly]\ \textcolor{keyword}{public}\ NativeArray<float>\ Output;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ unsafe\ \textcolor{keywordtype}{void}\ Execute(\textcolor{keywordtype}{int}\ index)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ Output[i]\ =\ math.sqrt(Input[i]);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


This runs 1.\+26x faster than the batched function pointer example, and 1.\+93x faster than the non-\/batched function pointer examples. \doxylink{namespace_burst}{Burst} has perfect aliasing knowledge and can make the broadest modifications to the above. This code is also a lot simpler than either of the function pointer cases. 