\chapter{Using the RTHandle system}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documendc069cf085d27118ba5dc3512b1af7fc}{}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documendc069cf085d27118ba5dc3512b1af7fc}\index{Using the RTHandle system@{Using the RTHandle system}}
\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documendc069cf085d27118ba5dc3512b1af7fc_autotoc_md1843}%
\Hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documendc069cf085d27118ba5dc3512b1af7fc_autotoc_md1843}%
 This page covers how to use the RTHandle system to manage render textures in your render pipeline. For information about the RTHandle system, see \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documentation_0i_2rthandle-system}{RTHandle system}{0} and \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen9dc7fefea40ec0f300e2f5293cf90ab5}{RTHandle system fundamentals}{0}.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documendc069cf085d27118ba5dc3512b1af7fc_autotoc_md1844}{}\doxysubsection{\texorpdfstring{Initializing the RTHandle System}{Initializing the RTHandle System}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documendc069cf085d27118ba5dc3512b1af7fc_autotoc_md1844}
All operations related to {\ttfamily RTHandles} require an instance of the {\ttfamily RTHandle\+System} class. This class contains all the APIs necessary to allocate RTHandles, release RTHandles, and set the reference size for the frame. This means that you must create and maintain an instance of {\ttfamily RTHandle\+System} in your render pipeline or make use of the static RTHandles class mentioned later in this section. To create your own instance of {\ttfamily RTHandle\+System}, see the following code sample\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{RTHandleSystem\ m\_RTHandleSystem\ =\ \textcolor{keyword}{new}\ RTHandleSystem();}
\DoxyCodeLine{m\_RTHandleSystem.Initialize(\mbox{\hyperlink{namespace_unity_engine_1_1_rendering_ab395affd52c7e0801e863f0422d736f4a2fc3359e12b2a9104121dcf04246f6a0}{Screen}}.width,\ \mbox{\hyperlink{namespace_unity_engine_1_1_rendering_ab395affd52c7e0801e863f0422d736f4a2fc3359e12b2a9104121dcf04246f6a0}{Screen}}.height);}

\end{DoxyCode}
 When you initialize the system, you must supply the starting resolution. The above code example uses the width and height of the screen. Because the RTHandle system only reallocates render textures when a Camera requires a resolution larger than the current maximum size, the internal {\ttfamily RTHandle} resolution can only increase from the value you pass in here. It is good practice to initialize this resolution to be the resolution of the main display. This means the system does not need to unnecessarily reallocate the render textures (and cause unwanted memory spikes) at the beginning of the application.

You must only call the {\ttfamily Initialize} function once at the beginning of the application. After this, you can use the initialized instance to allocate textures.

Because you allocate the majority of {\ttfamily RTHandles} from the same {\ttfamily RTHandle\+System} instance, the RTHandle system also provides a default global instance through the {\ttfamily RTHandles} static class. Rather than maintain your own instance of {\ttfamily RTHandle\+System}, this allows you to use the same API that you get with an instance, but not worry about the lifetime of the instance. Using the static instance, the initialization becomes this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{RTHandles.Initialize(\mbox{\hyperlink{namespace_unity_engine_1_1_rendering_ab395affd52c7e0801e863f0422d736f4a2fc3359e12b2a9104121dcf04246f6a0}{Screen}}.width,\ \mbox{\hyperlink{namespace_unity_engine_1_1_rendering_ab395affd52c7e0801e863f0422d736f4a2fc3359e12b2a9104121dcf04246f6a0}{Screen}}.height);}

\end{DoxyCode}


The code examples in the rest of this page use the default global instance.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documendc069cf085d27118ba5dc3512b1af7fc_autotoc_md1845}{}\doxysubsection{\texorpdfstring{Updating the RTHandle System}{Updating the RTHandle System}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documendc069cf085d27118ba5dc3512b1af7fc_autotoc_md1845}
Before rendering with a Camera, you need to set the resolution the RTHandle system uses as a reference size. To do so, call the {\ttfamily Set\+Reference\+Size} function.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{RTHandles.SetReferenceSize(width,\ height);}

\end{DoxyCode}


Calling this function has two effects\+:


\begin{DoxyEnumerate}
\item If the new reference size you provide is bigger than the current one, the RTHandle system reallocates all the render textures internally to match the new size.
\item After that, the RTHandle system updates internal properties that set viewport and render texture scales for when the system uses RTHandles as active render textures.
\end{DoxyEnumerate}\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documendc069cf085d27118ba5dc3512b1af7fc_autotoc_md1846}{}\doxysubsection{\texorpdfstring{Allocating and releasing RTHandles}{Allocating and releasing RTHandles}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documendc069cf085d27118ba5dc3512b1af7fc_autotoc_md1846}
After you initialize an instance of {\ttfamily RTHandle\+System}, whether this is your own instance or the static default instance, you can use it to allocate RTHandles.

There are three main ways to allocate an {\ttfamily RTHandle}. They all use the same {\ttfamily Alloc} method on the RTHandle\+System instance. Most of the parameters of these functions are the same as the regular \doxylink{namespace_unity}{Unity} Render\+Texture ones, so for more information see the \href{https://docs.unity3d.com/ScriptReference/RenderTexture.html}{\texttt{ Render\+Texture API documentation}}. This section focuses on the parameters that relate to the size of the {\ttfamily RTHandle}\+:


\begin{DoxyItemize}
\item {\ttfamily Vector2 scale\+Factor}\+: This variant requires a constant 2D scale for width and height. The RTHandle system uses this to calculate the resolution of the texture against the maximum reference size. For example, a scale of (1.\+0f, 1.\+0f) generates a full-\/screen texture. A scale of (0.\+5f 0.\+5f) generates a quarter-\/resolution texture.
\item {\ttfamily Scale\+Func scale\+Func}\+: For cases when you don\textquotesingle{}t want to use a constant scale to calculate the size of an {\ttfamily RTHandle}, you can provide a functor that calculates the size of the texture. The functor should take a {\ttfamily Vector2\+Int} as a parameter, which is the maximum reference size, and return a {\ttfamily Vector2\+In}t, which represents the size you want the texture to be.
\item {\ttfamily int width, int height}\+: This is for fixed-\/size textures. If you allocate a texture like this, it behaves like any regular Render\+Texture.
\end{DoxyItemize}

There are also overrides that create RTHandles from \href{https://docs.unity3d.com/ScriptReference/Rendering.RenderTargetIdentifier.html}{\texttt{ Render\+Target\+Identifier}}. \href{https://docs.unity3d.com/ScriptReference/RenderTexture.html}{\texttt{ Render\+Textures}}, or \href{https://docs.unity3d.com/Manual/Textures.html}{\texttt{ Textures}}. These are useful when you want to use the RTHandle API to interact with all your textures, even though the texture might not be an actual {\ttfamily RTHandle}.

The following code sample contains example uses of the {\ttfamily Alloc} function\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{\textcolor{comment}{//\ Simple\ Scale}}
\DoxyCodeLine{RTHandle\ simpleScale\ =\ RTHandles.Alloc(Vector2.one,\ depthBufferBits:\ \mbox{\hyperlink{namespace_unity_engine_1_1_rendering_a711f788583e4dd73903b42b11986f2c2}{DepthBits}}.\mbox{\hyperlink{namespace_unity_engine_1_1_rendering_a711f788583e4dd73903b42b11986f2c2a4dd2fd01dd0cd2912fa2189c4654a04e}{Depth32}},\ dimension:\ TextureDimension.Tex2D,\ name:\ \textcolor{stringliteral}{"{}CameraDepthStencil"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Functor}}
\DoxyCodeLine{Vector2Int\ ComputeRTHandleSize(Vector2Int\ screenSize)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ DoSpecificResolutionComputation(screenSize);}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{RTHandle\ rtHandleUsingFunctor\ =\ RTHandles.Alloc(ComputeRTHandleSize,\ colorFormat:\ GraphicsFormat.R32\_SFloat,\ dimension:\ TextureDimension.Tex2D);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Fixed\ size}}
\DoxyCodeLine{RTHandle\ fixedSize\ =\ RTHandles.Alloc(256,\ 256,\ colorFormat:\ GraphicsFormat.R8G8B8A8\_UNorm,\ dimension:\ TextureDimension.Tex2D);}

\end{DoxyCode}


When you no longer need a particular RTHandle, you can release it. To do this, call the {\ttfamily Release} method.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{myRTHandle.Release();}

\end{DoxyCode}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documendc069cf085d27118ba5dc3512b1af7fc_autotoc_md1847}{}\doxysection{\texorpdfstring{Using RTHandles}{Using RTHandles}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documendc069cf085d27118ba5dc3512b1af7fc_autotoc_md1847}
After you allocate an RTHandle, you can use it exactly like a regular Render\+Texture. There are implicit conversions to {\ttfamily Render\+Target\+Identifier} and {\ttfamily Render\+Texture}, which means you can use them with regular related \doxylink{namespace_unity}{Unity} APIs.

However, when you use the RTHandle system, the actual resolution of the {\ttfamily RTHandle} might be different from the current resolution. For example, if the main Camera renders at 1920x1080 and a secondary Camera renders at 512x512, all RTHandle resolutions are based on the 1920x1080 resolution, even when rendering at lower resolutions. Because of this, take care when you set an RTHandle up as a render target. There are a number of APIs available in the \href{../api/UnityEngine.Rendering.CoreUtils.html}{\texttt{ Core\+Utils}} class to help you with this. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keyword}{static}\ \textcolor{keywordtype}{void}\ SetRenderTarget(CommandBuffer\ cmd,\ RTHandle\ buffer,\ ClearFlag\ clearFlag,\ Color\ clearColor,\ \textcolor{keywordtype}{int}\ miplevel\ =\ 0,\ CubemapFace\ cubemapFace\ =\ CubemapFace.Unknown,\ \textcolor{keywordtype}{int}\ depthSlice\ =\ -\/1)}

\end{DoxyCode}
 This function sets the {\ttfamily RTHandle} as the active render target but also sets up the viewport based on the scale of the {\ttfamily RTHandle} and the current reference size, not the maximum size.

For example, when the reference size is 512x512, even if the maximum size is 1920x1080, a texture of scale (1.\+0f, 1.\+0f) uses the 512x512 size and therefore sets up a 512x512 viewport. A (0.\+5f, 0.\+5f) scaled texture sets up a viewport of 256x256 and so on. This means that, when using these helper functions, the RTHandle system generates the correct viewport based on the {\ttfamily RTHandle} parameters.

This example is one of many different overrides for the {\ttfamily Set\+Render\+Target} function. For the full list of overrides, see the \href{../api/UnityEngine.Rendering.CoreUtils.html\#UnityEngine_Rendering_CoreUtils_SetRenderTarget_CommandBuffer_RenderTargetIdentifier_RenderBufferLoadAction_RenderBufferStoreAction_RenderTargetIdentifier_RenderBufferLoadAction_RenderBufferStoreAction_UnityEngine_Rendering_ClearFlag_}{\texttt{ documentation}}.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documendc069cf085d27118ba5dc3512b1af7fc_autotoc_md1848}{}\doxysection{\texorpdfstring{Using RTHandles in shaders}{Using RTHandles in shaders}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documendc069cf085d27118ba5dc3512b1af7fc_autotoc_md1848}
When you sample from a full-\/screen render texture in a shader in the usual way, UVs span the whole 0 to 1 range. This is not always the case with {\ttfamily RTHandles}. The current rendering might only occur in a partial viewport. To take this into account, you must apply a scale to UVs when you sample {\ttfamily RTHandles} that use a scale. All the information necessary to handle {\ttfamily RTHandles} specificity inside shaders is in the {\ttfamily RTHandle\+Properties} structure that the {\ttfamily RTHandle\+System} instance provides. To access it, use\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{RTHandleProperties\ rtHandleProperties\ =\ RTHandles.rtHandleProperties;}

\end{DoxyCode}


This structure contains the following properties\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keyword}{struct\ }RTHandleProperties}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ Vector2Int\ previousViewportSize;}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ Vector2Int\ previousRenderTargetSize;}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ Vector2Int\ currentViewportSize;}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ Vector2Int\ currentRenderTargetSize;}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ Vector4\ rtHandleScale;}
\DoxyCodeLine{\}}

\end{DoxyCode}


This structure provides\+:


\begin{DoxyItemize}
\item The current viewport size. This is the reference size you set for rendering.
\item The current render target size. This is the actual size of the render texture based on the maximum reference size.
\item The {\ttfamily rt\+Handle\+Scale}. This is the scale to apply to full-\/screen UVs to sample an RTHandle.
\end{DoxyItemize}

Values for previous frames are also available. For more information, see Camera specific RTHandles. Generally, the most important property in this structure is {\ttfamily rt\+Handle\+Scale}. It allows you to scale full-\/screen UV coordinates and use the result to sample an RTHandle. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{float2\ scaledUVs\ =\ fullScreenUVs\ *\ rtHandleScale.xy;}

\end{DoxyCode}


However, because the partial viewport always starts at (0, 0), when you use integer pixel coordinates within the viewport to load content from a texture, there is no need to rescale them.

Another important thing to consider is that, when you render a full-\/screen quad into a partial viewport, there is no benefit from standard UV addressing mechanisms such as wrap or clamp. This is because the texture might be bigger than the viewport. For this reason, take care when you sample pixels outside of the viewport.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documendc069cf085d27118ba5dc3512b1af7fc_autotoc_md1849}{}\doxysubsection{\texorpdfstring{Custom SRP specific information}{Custom SRP specific information}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documendc069cf085d27118ba5dc3512b1af7fc_autotoc_md1849}
There are no shader constants provided by default with SRP. So, when you use RTHandles with your own SRP, you must provide these constants to their shaders themselves.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documendc069cf085d27118ba5dc3512b1af7fc_autotoc_md1850}{}\doxysection{\texorpdfstring{Camera specific RTHandles}{Camera specific RTHandles}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documendc069cf085d27118ba5dc3512b1af7fc_autotoc_md1850}
Most of the render textures that a rendering loop uses can be shared by all Cameras. If their content does not need to carry from one frame to another, this is fine. However, some render textures need persistence. A good example of this is using the main color buffer in subsequent frames for Temporal Anti-\/aliasing. This means that the Camera cannot share its RTHandle with other Cameras. Most of the time, this also means that these RTHandles must be at least double-\/buffered (written to during the current frame, read from during the previous frame). To address this problem, the RTHandle system includes {\ttfamily Buffered\+RTHandle\+Systems}.

A {\ttfamily Buffered\+RTHandle\+System} is an {\ttfamily RTHandle\+System} that can multi-\/buffer RTHandles. The principle is to identify a buffer by a unique ID and provide APIs to allocate a number of instances of the same buffer then retrieve them from previous frames. These are history buffers. Usually, you must allocate one {\ttfamily Buffered\+RTHandle\+System} for each Camera. Each one owns their Camera-\/specific RTHandles.

Not every Camera needs history buffers. For example, if a Camera does not need Temporal Anti-\/aliasing, you do not need to assign a {\ttfamily Buffered\+RTHandle\+System} to it. History buffers require memory which means you can save memory by not assigning history buffers to Cameras that do not need them. Another consequence is that the system only allocates history buffers at the resolution of the Camera that the buffers are for. If the main Camera is 1920x1080 and another Camera renders in 256x256 and needs a history color buffer, the second Camera only uses a 256x256 buffer and not a 1920x1080 buffer as the non-\/\+Camera specific RTHandles would. To create an instance of a {\ttfamily Buffered\+RTHandle\+System}, see the following code sample\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{BufferedRTHandleSystem\ \ m\_HistoryRTSystem\ =\ \textcolor{keyword}{new}\ BufferedRTHandleSystem();}

\end{DoxyCode}


To allocate an {\ttfamily RTHandle} using a {\ttfamily Buffered\+RTHandle\+System}, the process is different from a normal {\ttfamily RTHandle\+System}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keywordtype}{void}\ AllocBuffer(\textcolor{keywordtype}{int}\ bufferId,\ Func<RTHandleSystem,\ int,\ RTHandle>\ allocator,\ \textcolor{keywordtype}{int}\ bufferCount);}

\end{DoxyCode}


The {\ttfamily buffer\+Id} is a unique ID that the system uses to identify the buffer. The allocator is a function you provide to allocate the {\ttfamily RTHandles} when needed (all instances are not allocated upfront), and the {\ttfamily buffer\+Count} is the number of instances requested.

From there, you can retrieve each {\ttfamily RTHandle} by its ID and instance index like so\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{\textcolor{keyword}{public}\ RTHandle\ GetFrameRT(\textcolor{keywordtype}{int}\ bufferId,\ \textcolor{keywordtype}{int}\ frameIndex);}

\end{DoxyCode}


The frame index is between zero and the number of buffers minus one. Zero always represents the current frame buffer, one the previous frame buffer, two the one before that, and so on.

To release a buffered RTHandle, call the {\ttfamily Release} function on the {\ttfamily Buffered\+RTHandle\+System}, passing in the ID of the buffer to release\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keywordtype}{void}\ ReleaseBuffer(\textcolor{keywordtype}{int}\ bufferId);}

\end{DoxyCode}


In the same way that you provide the reference size for regular {\ttfamily RTHandle\+Systems}, you must do this for each instance of {\ttfamily Buffered\+RTHandle\+System}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keywordtype}{void}\ SwapAndSetReferenceSize(\textcolor{keywordtype}{int}\ width,\ \textcolor{keywordtype}{int}\ height);}

\end{DoxyCode}


This works the same way as regular RTHandle\+System but it also swaps the buffers internally so that the 0 index for {\ttfamily Get\+Frame\+RT} still references the current frame buffer. This slightly different way of handling Camera-\/specific buffers also has implications when you write shader code.

With a multi-\/buffered approach like this, {\ttfamily RTHandles} from a previous frame might have a different size to the one from the current frame. For example, this can happen with dynamic resolution or even when you resize the window in the Editor. This means that when you access a buffered {\ttfamily RTHandle} from a previous frame, you must scale it accordingly. The scale \doxylink{namespace_unity}{Unity} uses to do this is in {\ttfamily RTHandle\+Properties.\+rt\+Handle\+Scale.\+zw}. \doxylink{namespace_unity}{Unity} uses this in exactly the same way as {\ttfamily xy} for regular RTHandles. This is also the reason why {\ttfamily RTHandle\+Properties} contains the viewport and resolution of the previous frame. It can be useful when doing computation with history buffers.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documendc069cf085d27118ba5dc3512b1af7fc_autotoc_md1851}{}\doxysection{\texorpdfstring{Dynamic Resolution}{Dynamic Resolution}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documendc069cf085d27118ba5dc3512b1af7fc_autotoc_md1851}
One of the byproducts of the RTHandle \doxylink{namespace_system}{System} design is that you can also use it to simulate software dynamic resolution. Because the current resolution of the Camera is not directly correlated to the actual render texture objects, you can provide any resolution you want at the beginning of the frame and all render textures scale accordingly.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documendc069cf085d27118ba5dc3512b1af7fc_autotoc_md1852}{}\doxysection{\texorpdfstring{Reset Reference Size}{Reset Reference Size}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documendc069cf085d27118ba5dc3512b1af7fc_autotoc_md1852}
Sometimes, you might need to render to a higher resolution than normal for a short period of time. If your application does not require this resolution anymore, the additional memory allocated is wasted. To avoid that, you can reset the current maximum resolution of an {\ttfamily RTHandle\+System} like so\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{RTHandles.ResetReferenceSize(newWidth,\ newHeight);}

\end{DoxyCode}


This forces the RTHandle system to reallocate all RTHandles to the new provided size. This is the only way to shrink the size of {\ttfamily RTHandles}. 