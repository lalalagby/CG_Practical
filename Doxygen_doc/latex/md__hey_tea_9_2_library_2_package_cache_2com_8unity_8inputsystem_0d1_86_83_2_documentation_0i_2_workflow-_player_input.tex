\chapter{Workflow Overview -\/ Using an Actions Asset and Player\+Input Component}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_workflow-_player_input}{}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_workflow-_player_input}\index{Workflow Overview -\/ Using an Actions Asset and PlayerInput Component@{Workflow Overview -\/ Using an Actions Asset and PlayerInput Component}}
\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_workflow-_player_input_autotoc_md1611}%
\Hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_workflow-_player_input_autotoc_md1611}%
 

The highest level of abstraction provided by the Input \doxylink{namespace_system}{System} is when you use the \href{ActionAssets.html}{\texttt{ Actions Asset}} and the {\bfseries{\doxylink{class_player}{Player} Input component}} together.

The \doxylink{class_player}{Player} Input component takes a reference to an Actions Asset, and provides a way to make connections between the Actions defined in that asset, and C\# methods in your own Mono\+Behaviour scripts, so that your desired C\# methods are called when the user performs an input action.

It allows you to set up these connections using a UI in the inspector, instead of requiring you to write code to make those connections (as shown in the \href{Workflow-ActionsAsset.html}{\texttt{ previous workflow example}}), as well as letting you choose how those methods are called.

You would typically add the Player\+Input component to the same Game\+Object as your own Mono\+Behaviour script which contains the methods that should handle the response to the actions.



In the above example image, you can see the Player\+Input component set up to map the "{}move"{}, "{}jump"{} actions to {\ttfamily On\+Move} and {\ttfamily On\+Jump} methods in a script, via \doxylink{namespace_unity}{Unity} Events.

This is an example of the script which would provide an implementation of these methods


\begin{DoxyCode}{0}
\DoxyCodeLine{using\ UnityEngine;}
\DoxyCodeLine{using\ UnityEngine.InputSystem;}
\DoxyCodeLine{}
\DoxyCodeLine{//\ This\ script\ is\ designed\ to\ have\ the\ OnMove\ and}
\DoxyCodeLine{//\ OnJump\ methods\ called\ by\ a\ PlayerInput\ component}
\DoxyCodeLine{}
\DoxyCodeLine{public\ class\ ExampleScript\ :\ MonoBehaviour}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ Vector2\ moveAmount;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ public\ void\ OnMove(InputAction.CallbackContext\ context)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ //\ read\ the\ value\ for\ the\ "{}move"{}\ action\ each\ event\ call}
\DoxyCodeLine{\ \ \ \ \ \ \ \ moveAmount\ =\ context.ReadValue<Vector2>();}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ public\ void\ OnJump(InputAction.CallbackContext\ context)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ //\ your\ jump\ code\ goes\ here.}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ public\ void\ Update()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ //\ to\ use\ the\ Vector2\ value\ from\ the\ "{}move"{}\ action\ each}
\DoxyCodeLine{\ \ \ \ \ \ \ \ //\ frame,\ use\ the\ "{}moveAmount"{}\ variable\ here.}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\}}

\end{DoxyCode}


This workflow has pros and cons when compared to the previous workflow which uses an \href{Workflow-ActionsAsset.html}{\texttt{ Action Asset without a Player\+Input component}}.

You can see compared with the previous workflow code example that this method requires less code, because you do not have to reference the Actions Asset or set up the event handler methods in your own script. However it does require more set-\/up in the Editor, and could make debugging more difficult because the connections between your actions and code are not hard-\/coded.

As with the other workflows described in this section, there is a trade-\/off between flexibility, simplicity, and speed of implementation.

Using the \doxylink{class_player}{Player} Input component provides the flexibility of being able to connect any action to any public method on a Game\+Objectâ€™s component without writing code, and allows you to make modifications to these connections without modifying code.

However, although requiring less code, you may find that coding the connections in your own script is simpler and faster than setting up and keeping track of these connections in a Player\+Input component on a Game\+Object.

To get started using this workflow, \href{PlayerInput.html}{\texttt{ see the documentation for the Player Input component}}. 