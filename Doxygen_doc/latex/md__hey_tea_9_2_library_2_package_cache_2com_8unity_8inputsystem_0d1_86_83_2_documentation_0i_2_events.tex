\chapter{Input events}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events}{}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events}\index{Input events@{Input events}}
\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1362}%
\Hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1362}%

\begin{DoxyItemize}
\item Types of events
\begin{DoxyItemize}
\item State events
\item Device events
\item Text events
\end{DoxyItemize}
\item Working with events
\begin{DoxyItemize}
\item Listening to events
\item Reading state events
\item Creating events
\item Capturing events
\end{DoxyItemize}
\item Processing events
\begin{DoxyItemize}
\item Merging of events
\end{DoxyItemize}
\end{DoxyItemize}

The Input \doxylink{namespace_system}{System} is event-\/driven. All input is delivered as events, and you can generate custom input by injecting events. You can also observe all source input by listening in on the events flowing through the system.

\texorpdfstring{$>$}{>}{\bfseries{Note}}\+: Events are an advanced, mostly internal feature of the Input \doxylink{namespace_system}{System}. Knowledge of the event system is mostly useful if you want to support custom Devices, or change the behavior of existing Devices.

Input events are a low-\/level mechanism. Usually, you don\textquotesingle{}t need to deal with events if all you want to do is receive input for your app. Events are stored in unmanaged memory buffers and not converted to C\# heap objects. The Input \doxylink{namespace_system}{System} provides wrapper APIs, but unsafe code is required for more involved event manipulations.

Note that there are no routing mechanism. The runtime delivers events straight to the Input \doxylink{namespace_system}{System}, which then incorporates them directly into the Device state.

Input events are represented by the \href{../api/UnityEngine.InputSystem.LowLevel.InputEvent.html}{\texttt{ {\ttfamily Input\+Event}}} struct. Each event has a set of common properties\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Property   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Property   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-2}
\endhead
\href{../api/UnityEngine.InputSystem.LowLevel.InputEvent.html\#UnityEngine_InputSystem_LowLevel_InputEvent_type}{\texttt{ {\ttfamily type}}}   &\href{../api/UnityEngine.InputSystem.Utilities.FourCC.html}{\texttt{ {\ttfamily Four\+CC}}} code that indicates what type of event it is.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.LowLevel.InputEvent.html\#UnityEngine_InputSystem_LowLevel_InputEvent_eventId}{\texttt{ {\ttfamily event\+Id}}}   &Unique numeric ID of the event.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.LowLevel.InputEvent.html\#UnityEngine_InputSystem_LowLevel_InputEvent_time}{\texttt{ {\ttfamily time}}}   &Timestamp of when the event was generated. This is on the same timeline as \href{https://docs.unity3d.com/ScriptReference/Time-realtimeSinceStartup.html}{\texttt{ {\ttfamily Time.\+realtime\+Since\+Startup}}}.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.LowLevel.InputEvent.html\#UnityEngine_InputSystem_LowLevel_InputEvent_deviceId}{\texttt{ {\ttfamily device\+Id}}}   &ID of the Device that the event targets.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.LowLevel.InputEvent.html\#UnityEngine_InputSystem_LowLevel_InputEvent_sizeInBytes}{\texttt{ {\ttfamily size\+In\+Bytes}}}   &Total size of the event in bytes.   \\\cline{1-2}
\end{longtabu}


You can observe the events received for a specific input device in the \href{Debugging.md\#debugging-devices}{\texttt{ input debugger}}.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1363}{}\doxysection{\texorpdfstring{Types of events}{Types of events}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1363}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1364}{}\doxysubsection{\texorpdfstring{State events}{State events}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1364}
A state event contains the input state for a Device. The Input \doxylink{namespace_system}{System} uses these events to feed new input to Devices.

There are two types of state events\+:


\begin{DoxyItemize}
\item \href{../api/UnityEngine.InputSystem.LowLevel.StateEvent.html}{\texttt{ {\ttfamily State\+Event}}} (`\textquotesingle{}STAT'{\ttfamily )}
\item {\ttfamily \mbox{[}}Delta\+State\+Event{\ttfamily \mbox{]}(../api/\+Unity\+Engine.Input\+System.\+Low\+Level.\+State\+Event.\+html) (}\textquotesingle{}DLTA\textquotesingle{}\`{})
\end{DoxyItemize}

\href{../api/UnityEngine.InputSystem.LowLevel.StateEvent.html}{\texttt{ {\ttfamily State\+Event}}} contains a full snapshot of the entire state of a Device in the format specific to that Device. The \href{../api/UnityEngine.InputSystem.LowLevel.StateEvent.html\#UnityEngine_InputSystem_LowLevel_StateEvent_stateFormat}{\texttt{ {\ttfamily state\+Format}}} field identifies the type of the data in the event. You can access the raw data using the \href{../api/UnityEngine.InputSystem.LowLevel.StateEvent.html\#UnityEngine_InputSystem_LowLevel_StateEvent_state}{\texttt{ {\ttfamily state}}} pointer and \href{../api/UnityEngine.InputSystem.LowLevel.StateEvent.html\#UnityEngine_InputSystem_LowLevel_StateEvent_stateSizeInBytes}{\texttt{ {\ttfamily state\+Size\+In\+Bytes}}}.

A \href{../api/UnityEngine.InputSystem.LowLevel.DeltaStateEvent.html}{\texttt{ {\ttfamily Delta\+State\+Event}}} is like a \href{../api/UnityEngine.InputSystem.LowLevel.StateEvent.html}{\texttt{ {\ttfamily State\+Event}}}, but only contains a partial snapshot of the state of a Device. The Input \doxylink{namespace_system}{System} usually sends this for Devices that require a large state record, to reduce the amount of memory it needs to update if only some of the Controls change their state. To access the raw data, you can use the \href{../api/UnityEngine.InputSystem.LowLevel.DeltaStateEvent.html\#UnityEngine_InputSystem_LowLevel_DeltaStateEvent_deltaState}{\texttt{ {\ttfamily delta\+State}}} pointer and \href{../api/UnityEngine.InputSystem.LowLevel.DeltaStateEvent.html\#UnityEngine_InputSystem_LowLevel_DeltaStateEvent_deltaStateSizeInBytes}{\texttt{ {\ttfamily delta\+State\+Size\+In\+Bytes}}}. The Input \doxylink{namespace_system}{System} should apply the data to the Device\textquotesingle{}s state at the offset defined by \href{../api/UnityEngine.InputSystem.LowLevel.DeltaStateEvent.html\#UnityEngine_InputSystem_LowLevel_DeltaStateEvent_stateOffset}{\texttt{ {\ttfamily state\+Offset}}}.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1365}{}\doxysubsection{\texorpdfstring{Device events}{Device events}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1365}
Device events indicate a change that is relevant to a Device as a whole. If you\textquotesingle{}re interested in these events, it is usually more convenient to subscribe to the higher-\/level \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_onDeviceChange}{\texttt{ {\ttfamily Input\+System.\+on\+Device\+Change}}} event rather then processing \href{../api/UnityEngine.InputSystem.LowLevel.InputEvent.html}{\texttt{ {\ttfamily Input\+Events}}} yourself.

There are three types of Device events\+:


\begin{DoxyItemize}
\item \href{../api/UnityEngine.InputSystem.LowLevel.DeviceRemoveEvent.html}{\texttt{ {\ttfamily Device\+Remove\+Event}}} (`\textquotesingle{}DREM'{\ttfamily )}
\item {\ttfamily \mbox{[}}Device\+Configuration\+Event{\ttfamily \mbox{]}(../api/\+Unity\+Engine.Input\+System.\+Low\+Level.\+Device\+Configuration\+Event.\+html) (}\textquotesingle{}DCFG\textquotesingle{}{\ttfamily )}
\item {\ttfamily \mbox{[}}Device\+Reset\+Event{\ttfamily \mbox{]}(../api/\+Unity\+Engine.Input\+System.\+Low\+Level.\+Device\+Reset\+Event.\+html) (}\textquotesingle{}DRST\textquotesingle{}\`{})
\end{DoxyItemize}

{\ttfamily Device\+Removed\+Event} indicates that a Device has been removed or disconnected. To query the device that has been removed, you can use the common \href{../api/UnityEngine.InputSystem.LowLevel.InputEvent.html\#UnityEngine_InputSystem_LowLevel_InputEvent_deviceId}{\texttt{ {\ttfamily device\+Id}}} field. This event doesn\textquotesingle{}t have any additional data.

{\ttfamily Device\+Configuration\+Event} indicates that the configuration of a Device has changed. The meaning of this is Device-\/specific. This might signal, for example, that the layout used by the keyboard has changed or that, on a console, a gamepad has changed which player ID(s) it is assigned to. You can query the changed device from the common \href{../api/UnityEngine.InputSystem.LowLevel.InputEvent.html\#UnityEngine_InputSystem_LowLevel_InputEvent_deviceId}{\texttt{ {\ttfamily device\+Id}}} field. This event doesn\textquotesingle{}t have any additional data.

{\ttfamily Device\+Reset\+Event} indicates that a device should get reset. This will trigger \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_ResetDevice_UnityEngine_InputSystem_InputDevice_System_Boolean_}{\texttt{ {\ttfamily Input\+System.\+Reset\+Device}}} to be called on the Device.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1366}{}\doxysubsection{\texorpdfstring{Text events}{Text events}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1366}
\doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_keyboard}{Keyboard}{0} devices send these events to handle text input. If you\textquotesingle{}re interested in these events, it\textquotesingle{}s usually more convenient to subscribe to the higher-\/level \href{Keyboard.md\#text-input}{\texttt{ callbacks on the Keyboard class}} rather than processing \href{../api/UnityEngine.InputSystem.LowLevel.InputEvent.html}{\texttt{ {\ttfamily Input\+Events}}} yourself.

There are two types of text events\+:


\begin{DoxyItemize}
\item \href{../api/UnityEngine.InputSystem.LowLevel.TextEvent.html}{\texttt{ {\ttfamily Text\+Event}}} (`\textquotesingle{}TEXT'{\ttfamily )}
\item {\ttfamily \mbox{[}}IMEComposition\+Event{\ttfamily \mbox{]}(../api/\+Unity\+Engine.Input\+System.\+Low\+Level.\+IMEComposition\+Event.\+html) (}\textquotesingle{}IMES\textquotesingle{}\`{})
\end{DoxyItemize}\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1367}{}\doxysection{\texorpdfstring{Working with events}{Working with events}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1367}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1368}{}\doxysubsection{\texorpdfstring{Listening to events}{Listening to events}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1368}
If you want to do any monitoring or processing on incoming events yourself, subscribe to the \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_onEvent}{\texttt{ {\ttfamily Input\+System.\+on\+Event}}} callback.


\begin{DoxyCode}{0}
\DoxyCodeLine{InputSystem.onEvent\ +=}
\DoxyCodeLine{\ \ \ (eventPtr,\ device)\ =>}
\DoxyCodeLine{\ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ Debug.Log(\$\textcolor{stringliteral}{"{}Received\ event\ for\ \{device\}"{}});}
\DoxyCodeLine{\ \ \ \};}

\end{DoxyCode}


An \href{https://docs.microsoft.com/en-us/dotnet/api/system.iobservable-1}{\texttt{ {\ttfamily IObservable}}} interface is provided to more conveniently process events.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Wait\ for\ first\ button\ press\ on\ a\ gamepad.}}
\DoxyCodeLine{InputSystem.onEvent}
\DoxyCodeLine{\ \ \ \ .ForDevice<Gamepad>()}
\DoxyCodeLine{\ \ \ \ .Where(e\ =>\ e.HasButtonPress())}
\DoxyCodeLine{\ \ \ \ .CallOnce(ctrl\ =>\ Debug.Log(\$\textcolor{stringliteral}{"{}Button\ \{ctrl\}\ pressed"{}}));}

\end{DoxyCode}


To enumerate the controls that have value changes in an event, you can use \href{../api/UnityEngine.InputSystem.InputControlExtensions.html\#UnityEngine_InputSystem_InputControlExtensions_EnumerateChangedControls_UnityEngine_InputSystem_LowLevel_InputEventPtr_UnityEngine_InputSystem_InputDevice_System_Single_}{\texttt{ {\ttfamily Input\+Control\+Extensions.\+Enumerate\+Changed\+Controls}}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{InputSystem.onEvent}
\DoxyCodeLine{\ \ \ \ .Call(eventPtr\ =>}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{foreach}\ (var\ control\ \textcolor{keywordflow}{in}\ eventPtr.EnumerateChangedControls())}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ Debug.Log(\$\textcolor{stringliteral}{"{}Control\ \{control\}\ changed\ value\ to\ \{control.ReadValueFromEventAsObject(eventPtr)\}"{}});}
\DoxyCodeLine{\ \ \ \ \};}

\end{DoxyCode}


This is significantly more efficient than manually iterating over \href{../api/UnityEngine.InputSystem.InputDevice.html\#UnityEngine_InputSystem_InputDevice_allControls}{\texttt{ {\ttfamily Input\+Device.\+all\+Controls}}} and reading out the value of each control from the event.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1369}{}\doxysubsection{\texorpdfstring{Reading state events}{Reading state events}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1369}
State events contain raw memory snapshots for Devices. As such, interpreting the data in the event requires knowledge about where and how individual state is stored for a given Device.

The easiest way to access state contained in a state event is to rely on the Device that the state is meant for. You can ask any Control to read its value from a given event rather than from its own internally stored state.

For example, the following code demonstrates how to read a value for \href{../api/UnityEngine.InputSystem.Gamepad.html\#UnityEngine_InputSystem_Gamepad_leftStick}{\texttt{ {\ttfamily Gamepad.\+left\+Stick}}} from a state event targeted at a \href{../api/UnityEngine.InputSystem.Gamepad.html}{\texttt{ {\ttfamily Gamepad}}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{InputSystem.onEvent\ +=}
\DoxyCodeLine{\ \ \ \ (eventPtr,\ device)\ =>}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Ignore\ anything\ that\ isn't\ a\ state\ event.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!eventPtr.IsA<StateEvent>()\ \&\&\ !eventPtr.IsA<DeltaStateEvent>())}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ var\ gamepad\ =\ device\ as\ Gamepad;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (gamepad\ ==\ \textcolor{keyword}{null})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Event\ isn't\ for\ a\ gamepad\ or\ device\ ID\ is\ no\ longer\ valid.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return};}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ var\ leftStickValue\ =\ gamepad.leftStick.ReadValueFromEvent(eventPtr);}
\DoxyCodeLine{\ \ \ \ \};}

\end{DoxyCode}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1370}{}\doxysubsection{\texorpdfstring{Creating events}{Creating events}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1370}
Anyone can create and queue new input events against any existing Device. Queueing an input event is thread-\/safe, which means that event generation can happen in background threads.

\texorpdfstring{$>$}{>}{\bfseries{Note}}\+: \doxylink{namespace_unity}{Unity} allocates limited memory to events that come from background threads. If background threads produce too many events, queueing an event from a thread blocks the thread until the main thread flushes out the background event queue.

Note that queuing an event doesn\textquotesingle{}t immediately consume the event. Event processing happens on the next update (depending on \href{Settings.md\#update-mode}{\texttt{ {\ttfamily Input\+Settings.\+update\+Mode}}}, it is triggered either manually via \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_Update}{\texttt{ {\ttfamily Input\+System.\+Update}}}, or automatically as part of the \doxylink{class_player}{Player} loop).\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1371}{}\doxysubsubsection{\texorpdfstring{Sending state events}{Sending state events}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1371}
For Devices that have a corresponding "{}state struct"{} describing the state of the device, the easiest way of sending input to the Device is to simply queue instances of those structs\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Mouse.}}
\DoxyCodeLine{InputSystem.QueueStateEvent(Mouse.current,\ \textcolor{keyword}{new}\ MouseState\ \{\ position\ =\ new\ Vector2(123,\ 234)\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Keyboard.}}
\DoxyCodeLine{InputSystem.QueueStateEvent(Keyboard.current,\ \textcolor{keyword}{new}\ KeyboardState(\mbox{\hyperlink{namespace_unity_engine_1_1_input_system_ad8a6cae0143584257f5a72d1842ea496}{Key}}.LeftCtrl,\ \mbox{\hyperlink{namespace_unity_engine_1_1_input_system_ad8a6cae0143584257f5a72d1842ea496}{Key}}.A));}

\end{DoxyCode}


{\ttfamily Touchscreen} is somewhat special in that it expects its input to be in \href{../api/UnityEngine.InputSystem.LowLevel.TouchState.html}{\texttt{ {\ttfamily Touch\+State}}} format.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Start\ touch.}}
\DoxyCodeLine{InputSystem.QueueStateEvent(Touchscreen.current,}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{new}\ TouchState\ \{\ touchId\ =\ 1,\ phase\ =\ TouchPhase.Began,\ position\ =\ new\ Vector2(123,\ 234)\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Move\ touch.}}
\DoxyCodeLine{InputSystem.QueueStateEvent(Touchscreen.current,}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{new}\ TouchState\ \{\ touchId\ =\ 1,\ phase\ =\ TouchPhase.Moved,\ position\ =\ new\ Vector2(234,\ 345)\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ End\ touch.}}
\DoxyCodeLine{InputSystem.QueueStateEvent(Touchscreen.current,}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{new}\ TouchState\ \{\ touchId\ =\ 1,\ phase\ =\ TouchPhase.Ended,\ position\ =\ new\ Vector2(123,\ 234)\ \});}

\end{DoxyCode}


\texorpdfstring{$>$}{>}{\bfseries{IMPORTANT\+:}} \href{../api/UnityEngine.InputSystem.Controls.TouchControl.html\#UnityEngine_InputSystem_Controls_TouchControl_touchId}{\texttt{ Touch IDs}} cannot be 0! A valid touch must have a non-\/zero touch ID. Concurrent touches must each have a unique ID. After a touch has ended, its ID can be reused -- although it is recommended to not do so.

If the exact format of the state used by a given Device is not known, the easiest way to send input to it is to simply create a \href{../api/UnityEngine.InputSystem.LowLevel.StateEvent.html}{\texttt{ {\ttfamily State\+Event}}} from the Device itself\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ \`{}StateEvent.From`\ creates\ a\ temporary\ buffer\ in\ unmanaged\ memory\ that\ holds}}
\DoxyCodeLine{\textcolor{comment}{//\ a\ state\ event\ large\ enough\ for\ the\ given\ device\ and\ contains\ a\ memory}}
\DoxyCodeLine{\textcolor{comment}{//\ copy\ of\ the\ device's\ current\ state.}}
\DoxyCodeLine{InputEventPtr\ eventPtr;}
\DoxyCodeLine{\textcolor{keyword}{using}\ (StateEvent.From(myDevice,\ out\ eventPtr))}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ ((AxisControl)\ myDevice[\textcolor{stringliteral}{"{}myControl"{}}]).WriteValueIntoEvent(0.5f,\ eventPtr);}
\DoxyCodeLine{\ \ \ \ InputSystem.QueueEvent(eventPtr);}
\DoxyCodeLine{\}}

\end{DoxyCode}


Alternatively, you can send events for individual Controls.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Send\ event\ to\ update\ leftStick\ on\ the\ gamepad.}}
\DoxyCodeLine{InputSystem.QueueDeltaStateEvent(Gamepad.current.leftStick,}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{new}\ Vector2(0.123f,\ 0.234f);}

\end{DoxyCode}


Note that delta state events only work for Controls that are both byte-\/aligned and a multiple of 8 bits in size in memory. You can\textquotesingle{}t send a delta state event for a button Control that is stored as a single bit, for example.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1372}{}\doxysubsection{\texorpdfstring{Capturing Events}{Capturing Events}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1372}
\texorpdfstring{$>$}{>}NOTE\+: To download a sample project which contains a reusable Mono\+Behaviour called {\ttfamily Input\+Recorder}, which can capture and replay input from arbitrary devices, open the Package Manager, select the Input \doxylink{namespace_system}{System} Package, and choose the sample project "{}\+Input Recorder"{} to download.

You can use the \href{../api/UnityEngine.InputSystem.LowLevel.InputEventTrace.html}{\texttt{ {\ttfamily Input\+Event\+Trace}}} class to record input events for later processing\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ trace\ =\ \textcolor{keyword}{new}\ InputEventTrace();\ \textcolor{comment}{//\ Can\ also\ give\ device\ ID\ to\ only}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ trace\ events\ for\ a\ specific\ device.}}
\DoxyCodeLine{}
\DoxyCodeLine{trace.Enable();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//...\ run\ stuff}}
\DoxyCodeLine{}
\DoxyCodeLine{var\ current\ =\ \textcolor{keyword}{new}\ InputEventPtr();}
\DoxyCodeLine{\textcolor{keywordflow}{while}\ (trace.GetNextEvent(ref\ current))}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ Debug.Log(\textcolor{stringliteral}{"{}Got\ some\ event:\ "{}}\ +\ current);}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Also\ supports\ IEnumerable.}}
\DoxyCodeLine{\textcolor{keywordflow}{foreach}\ (var\ eventPtr\ \textcolor{keywordflow}{in}\ trace)}
\DoxyCodeLine{\ \ \ \ Debug.Log(\textcolor{stringliteral}{"{}Got\ some\ event:\ "{}}\ +\ eventPtr);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Trace\ consumes\ unmanaged\ resources.\ Make\ sure\ to\ dispose.}}
\DoxyCodeLine{trace.Dispose();}

\end{DoxyCode}


Dispose event traces after use, so that they do not leak memory on the unmanaged (C++) memory heap.

You can also write event traces out to files/streams, load them back in, and replay recorded streams.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Set\ up\ a\ trace\ with\ such\ that\ it\ automatically\ grows\ in\ size\ as\ needed.}}
\DoxyCodeLine{var\ trace\ =\ \textcolor{keyword}{new}\ InputEventTrace(growBuffer:\ true);}
\DoxyCodeLine{trace.Enable();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ ...\ capture\ some\ input\ ...}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Write\ trace\ to\ file.}}
\DoxyCodeLine{trace.WriteTo(\textcolor{stringliteral}{"{}mytrace.inputtrace."{}});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Load\ trace\ from\ same\ file.}}
\DoxyCodeLine{var\ loadedTrace\ =\ InputEventTrace.LoadFrom(\textcolor{stringliteral}{"{}mytrace.inputtrace"{}});}

\end{DoxyCode}


You can replay captured traces directly from \href{../api/UnityEngine.InputSystem.LowLevel.InputEventTrace.html}{\texttt{ {\ttfamily Input\+Event\+Trace}}} instances using the \href{../api/UnityEngine.InputSystem.LowLevel.InputEventTrace.html\#UnityEngine_InputSystem_LowLevel_InputEventTrace_Replay_}{\texttt{ {\ttfamily Replay}}} method.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ The\ Replay\ method\ returns\ a\ ReplayController\ that\ can\ be\ used\ to}}
\DoxyCodeLine{\textcolor{comment}{//\ configure\ and\ control\ playback.}}
\DoxyCodeLine{var\ controller\ =\ trace.Replay();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ For\ example,\ to\ not\ replay\ the\ events\ as\ is\ but\ rather\ create\ new\ devices\ and\ send}}
\DoxyCodeLine{\textcolor{comment}{//\ the\ events\ to\ them,\ call\ WithAllDevicesMappedToNewInstances.}}
\DoxyCodeLine{controller.WithAllDevicessMappedToNewInstances();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Replay\ all\ frames\ one\ by\ one.}}
\DoxyCodeLine{controller.PlayAllFramesOnyByOne();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Replay\ events\ in\ a\ way\ that\ tries\ to\ simulate\ original\ event\ timing.}}
\DoxyCodeLine{controller.PlayAllEventsAccordingToTimestamps();}

\end{DoxyCode}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1373}{}\doxysection{\texorpdfstring{Processing events}{Processing events}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1373}
\href{../api/UnityEngine.InputSystem.LowLevel.InputEvent.html}{\texttt{ Events}} are collected on a queue by the \doxylink{namespace_unity}{Unity} runtime. This queue is regularly flushed out and the events on it processed. Events can be added to the queue manually by calling \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_QueueEvent_UnityEngine_InputSystem_LowLevel_InputEventPtr_}{\texttt{ {\ttfamily Input\+System.\+Queue\+Event}}}.

Each time input is processed, \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_Update_}{\texttt{ {\ttfamily Input\+System.\+Update}}} is called implicitly by the \doxylink{namespace_unity}{Unity} runtime.

The interval at which this happens is determined by the \href{Settings.md\#update-mode}{\texttt{ "{}\+Update Mode"{}}} configured in the settings. By default, input is processed in each frame {\bfseries{before}} {\ttfamily Mono\+Behaviour.\+Update} methods are called. If the setting is changed to process input in fixed updates, then this changes to input being processed each time before {\ttfamily Mono\+Behaviour.\+Fixed\+Update} methods are called.

Normally, when input is processed, {\bfseries{all}} outstanding input events on the queue will be consumed. There are two exceptions to this, however.

When using \href{../api/UnityEngine.InputSystem.InputSettings.UpdateMode.html\#UnityEngine_InputSystem_InputSettings_UpdateMode_ProcessEventsInFixedUpdate}{\texttt{ {\ttfamily Update\+Mode.\+Process\+Events\+In\+Fixed\+Update}}}, the Input \doxylink{namespace_system}{System} attempts to associate events with the timeslice of the corresponding {\ttfamily Fixed\+Update}. This is based on the \href{../api/UnityEngine.InputSystem.LowLevel.InputEvent.html\#UnityEngine_InputSystem_LowLevel_InputEvent_time}{\texttt{ timestamps}} of the events and a "{}best effort"{} at calculating the corresponding timeslice of the current {\ttfamily Fixed\+Updated}.

The other exception are \href{../api/UnityEngine.InputSystem.LowLevel.InputUpdateType.html\#UnityEngine_InputSystem_LowLevel_InputUpdateType_BeforeRender}{\texttt{ {\ttfamily Before\+Render}}} updates. These updates are run after fixed or dynamic updates but before rendering and used used exclusively to update devices such as VR headsets that need the most up-\/to-\/date tracking data. Other input is not consumed from such updates and these updates are only enabled if such devices are actually present. {\ttfamily Before\+Render} updates are not considered separate frames as far as input is concerned.

\texorpdfstring{$>$}{>}{\bfseries{Note}}\+: Manually calling \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_Update_}{\texttt{ {\ttfamily Input\+System.\+Update}}} is strongly advised against except within tests employing \href{../api/UnityEngine.InputSystem.InputTestFixture.html}{\texttt{ {\ttfamily Input\+Test\+Fixture}}} or when explicitly setting the system to \href{../api/UnityEngine.InputSystem.InputSettings.UpdateMode.html\#UnityEngine_InputSystem_InputSettings_UpdateMode_ProcessEventsManually}{\texttt{ manual update mode}}.

Methods such as \href{../api/UnityEngine.InputSystem.InputAction.html\#UnityEngine_InputSystem_InputAction_WasPerformedThisFrame}{\texttt{ {\ttfamily Input\+Action.\+Was\+Performed\+This\+Frame}}} and \href{../api/UnityEngine.InputSystem.InputAction.html\#UnityEngine_InputSystem_InputAction_WasPerformedThisFrame}{\texttt{ {\ttfamily Input\+Action.\+Was\+Performed\+This\+Frame}}} operate implicitly based on the \mbox{[}{\ttfamily Input\+System.\+Update}\mbox{]} cadence described above. Meaning, that they refer to the state as per the {\bfseries{last}} fixed/dynamic/manual update happened.

You can query the \href{../api/UnityEngine.InputSystem.LowLevel.InputState.html\#UnityEngine_InputSystem_LowLevel_InputState_currentUpdateType}{\texttt{ current/last update type}} and \href{../api/UnityEngine.InputSystem.LowLevel.InputState.html\#UnityEngine_InputSystem_LowLevel_InputState_updateCount}{\texttt{ count}} from \href{../api/UnityEngine.InputSystem.LowLevel.InputState.html}{\texttt{ {\ttfamily Input\+State}}}.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1374}{}\doxysubsection{\texorpdfstring{Merging of events}{Merging of events}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events_autotoc_md1374}
Input system uses event mering to reduce amount of events required to be processed. This greatly improves performance when working with high refresh rate devices like 8000 Hz mice, touchscreens and others.

For example let\textquotesingle{}s take a stream of 7 mouse events coming in the same update\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Mouse\ \ \ \ \ \ \ Mouse\ \ \ \ \ \ \ Mouse\ \ \ \ \ \ \ Mouse\ \ \ \ \ \ \ Mouse\ \ \ \ \ \ \ Mouse\ \ \ \ \ \ \ Mouse}
\DoxyCodeLine{Event\ no1\ \ \ Event\ no2\ \ \ Event\ no3\ \ \ Event\ no4\ \ \ Event\ no5\ \ \ Event\ no6\ \ \ Event\ no7}
\DoxyCodeLine{Time\ 1\ \ \ \ \ \ Time\ 2\ \ \ \ \ \ Time\ 3\ \ \ \ \ \ Time\ 4\ \ \ \ \ \ Time\ 5\ \ \ \ \ \ Time\ 6\ \ \ \ \ \ Time\ 7}
\DoxyCodeLine{Pos(10,20)\ \ Pos(12,21)\ \ Pos(13,23)\ \ Pos(14,24)\ \ Pos(16,25)\ \ Pos(17,27)\ \ Pos(18,28)}
\DoxyCodeLine{Delta(1,1)\ \ Delta(2,1)\ \ Delta(1,2)\ \ Delta(1,1)\ \ Delta(2,1)\ \ Delta(1,2)\ \ Delta(1,1)}
\DoxyCodeLine{BtnLeft(0)\ \ BtnLeft(0)\ \ BtnLeft(0)\ \ BtnLeft(1)\ \ BtnLeft(1)\ \ BtnLeft(1)\ \ BtnLeft(1)}

\end{DoxyCode}


To reduce workload we can skip events that are not encoding button state changes\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Mouse\ \ \ \ \ \ \ Mouse\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Mouse}
\DoxyCodeLine{Time\ 3\ \ \ \ \ \ Time\ 4\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Time\ 7}
\DoxyCodeLine{Event\ no3\ \ \ Event\ no4\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Event\ no7}
\DoxyCodeLine{Pos(13,23)\ \ Pos(14,24)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Pos(18,28)}
\DoxyCodeLine{Delta(3,3)\ \ Delta(1,1)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Delta(4,4)}
\DoxyCodeLine{BtnLeft(0)\ \ BtnLeft(1)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ BtnLeft(1)}

\end{DoxyCode}


In that case we combine no1, no2, no3 together into no3 and accumulate the delta, then we keep no4 because it stores the transition from button unpressed to button pressed, and it\textquotesingle{}s important to keep the exact timestamp of such transition. Later we combine no5, no6, no7 together into no7 because it is the last event in the update.

Currently this approach is implemented for\+:
\begin{DoxyItemize}
\item {\ttfamily Fast\+Mouse}, combines events unless {\ttfamily buttons} or {\ttfamily click\+Count} differ in {\ttfamily Mouse\+State}.
\item {\ttfamily Touchscreen}, combines events unless {\ttfamily touch\+Id}, {\ttfamily phase\+Id} or {\ttfamily flags} differ in {\ttfamily Touch\+State}.
\end{DoxyItemize}

You can disable merging of events by\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{InputSystem.settings.disableRedundantEventsMerging\ =\ true;}

\end{DoxyCode}
 