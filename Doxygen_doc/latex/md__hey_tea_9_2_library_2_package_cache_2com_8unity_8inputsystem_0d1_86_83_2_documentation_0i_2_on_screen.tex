\chapter{On-\/screen Controls}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_on_screen}{}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_on_screen}\index{On-\/screen Controls@{On-\/screen Controls}}
\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_on_screen_autotoc_md1498}%
\Hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_on_screen_autotoc_md1498}%
 You can use on-\/screen Controls to simulate Input Devices with UI widgets that the user interacts with on the screen. The most prominent example is the use of stick and button widgets on touchscreens to emulate a joystick or gamepad.

There are currently two Control types implemented out of the box\+: buttons and sticks. You can implement custom Controls by extending the base \href{../api/UnityEngine.InputSystem.OnScreen.OnScreenControl.html}{\texttt{ {\ttfamily On\+Screen\+Control}}} class (see documentation on writing custom on screen Controls to learn more).

\texorpdfstring{$>$}{>}{\bfseries{Note}}\+: On-\/screen Controls don\textquotesingle{}t have a predefined visual representation. It\textquotesingle{}s up to you to set up the visual aspect of a Control (for example, by adding a sprite or UI component to the Game\+Object). On-\/screen Controls take care of the interaction logic and of setting up and generating input from interactions.

Each on-\/screen Control uses a \href{Controls.md\#control-paths}{\texttt{ Control path}} to reference the Control that it should report input as. For example, the following on-\/screen button reports input as the right shoulder button of a gamepad\+:



The collection of on-\/screen Controls present in a Scene forms one or more \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices}{Input Devices}{0}. The Input \doxylink{namespace_system}{System} creates one Input Device for each distinct type of Device the Controls reference. For example, if one on-\/screen button references {\ttfamily \texorpdfstring{$<$}{<}Gamepad\texorpdfstring{$>$}{>}/button\+South} and another on-\/screen button references {\ttfamily \texorpdfstring{$<$}{<}Keyboard\texorpdfstring{$>$}{>}/a}, the Input \doxylink{namespace_system}{System} creates both a {\ttfamily Gamepad} and a {\ttfamily Keyboard}. This happens automatically when the components are enabled. When disabled, the Input \doxylink{namespace_system}{System} automatically removes the Devices again.

To query the Control (and, implicitly, the Device) that an on-\/screen Control feeds into, you can use the \href{../api/UnityEngine.InputSystem.OnScreen.OnScreenControl.html\#UnityEngine_InputSystem_OnScreen_OnScreenControl_control}{\texttt{ {\ttfamily On\+Screen\+Control.\+control}}} property.

\texorpdfstring{$>$}{>}{\bfseries{Note}}\+: This design allows you to use on-\/screen Controls to create input for arbitrary Input Devices, in addition to joysticks and gamepads.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_on_screen_autotoc_md1499}{}\doxysection{\texorpdfstring{On-\/screen buttons}{On-\/screen buttons}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_on_screen_autotoc_md1499}
To create an on-\/screen button\+:


\begin{DoxyEnumerate}
\item Add a UI {\ttfamily Button} object.
\item Add the \href{../api/UnityEngine.InputSystem.OnScreen.OnScreenButton.html}{\texttt{ {\ttfamily On\+Screen\+Button}}} component to it.
\item Set the \href{../api/UnityEngine.InputSystem.OnScreen.OnScreenControl.html\#UnityEngine_InputSystem_OnScreen_OnScreenControl_controlPath}{\texttt{ {\ttfamily Control Path}}} to refer to a \href{../api/UnityEngine.InputSystem.Controls.ButtonControl.html}{\texttt{ {\ttfamily Button\+Control}}} (for example, {\ttfamily \texorpdfstring{$<$}{<}Gamepad\texorpdfstring{$>$}{>}/button\+South}). The type of device referenced by the control path determines the type of virtual device created by the component.
\end{DoxyEnumerate}



The \href{../api/UnityEngine.InputSystem.OnScreen.OnScreenButton.html}{\texttt{ {\ttfamily On\+Screen\+Button}}} component requires the target Control to be a {\ttfamily Button} Control. \href{../api/UnityEngine.InputSystem.OnScreen.OnScreenButton.html}{\texttt{ {\ttfamily On\+Screen\+Button}}} sets the target Control value to 1 when it receives a pointer-\/down ({\ttfamily IPointer\+Down\+Handler.\+On\+Pointer\+Down}) event, or 0 when it receives a pointer-\/up ({\ttfamily IPointer\+Up\+Handler.\+On\+Pointer\+Up}) event.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_on_screen_autotoc_md1500}{}\doxysection{\texorpdfstring{On-\/screen sticks}{On-\/screen sticks}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_on_screen_autotoc_md1500}
To create an on-\/screen stick\+:


\begin{DoxyEnumerate}
\item Create a UI {\ttfamily Image} object.
\item Add the \href{../api/UnityEngine.InputSystem.OnScreen.OnScreenStick.html}{\texttt{ {\ttfamily On\+Screen\+Stick}}} component to it.
\item Set the \href{../api/UnityEngine.InputSystem.OnScreen.OnScreenControl.html\#UnityEngine_InputSystem_OnScreen_OnScreenControl_controlPath}{\texttt{ {\ttfamily Control Path}}} to refer to a \href{../api/UnityEngine.InputSystem.Controls.Vector2Control.html}{\texttt{ {\ttfamily Vector2\+Control}}} (for example, {\ttfamily \texorpdfstring{$<$}{<}Gamepad\texorpdfstring{$>$}{>}/left\+Stick}). The type of device referenced by the control path determines the type of virtual device created by the component.
\end{DoxyEnumerate}



The \href{../api/UnityEngine.InputSystem.OnScreen.OnScreenStick.html}{\texttt{ {\ttfamily On\+Screen\+Stick}}} component requires the target Control to be a {\ttfamily Vector2} Control. \href{../api/UnityEngine.InputSystem.OnScreen.OnScreenStick.html}{\texttt{ {\ttfamily On\+Screen\+Stick}}} starts the movement of the stick Control when it receives a pointer-\/down ({\ttfamily IPointer\+Down\+Handler.\+On\+Pointer\+Down}) event, and stops it when it receives a pointer-\/up ({\ttfamily IPointer\+Up\+Handler.\+On\+Pointer\+Up}) event.

In-\/between, the stick moves according to the pointer being dragged ({\ttfamily IDrag\+Handler.\+On\+Drag}) within a box centered on the pointer-\/down screen point, and with an edge length defined in the component\textquotesingle{}s {\bfseries{Movement Range}} property. A movement range of 50, for example, means that the stick\textquotesingle{}s on-\/screen area is 25 pixels up, down, left, and right of the pointer-\/down point on screen.

If you want to be notified when the user starts and/or stops touching the on-\/screen stick, implement {\ttfamily IPointer\+Down\+Handler} and/or {\ttfamily IPointer\+Up\+Handler} on a component and add it to the stick {\ttfamily Game\+Object}.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_on_screen_autotoc_md1501}{}\doxysubsection{\texorpdfstring{Isolated mode}{Isolated mode}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_on_screen_autotoc_md1501}
The \href{../api/UnityEngine.InputSystem.OnScreen.OnScreenStick.html}{\texttt{ {\ttfamily On\+Screen\+Stick}}} simulates input events from the device specified in the \href{../api/UnityEngine.InputSystem.OnScreen.OnScreenControl.html\#UnityEngine_InputSystem_OnScreen_OnScreenControl_control}{\texttt{ {\ttfamily On\+Screen\+Control.\+control}}} property. To the Input \doxylink{namespace_system}{System} itself, these are normal events and can cause the paired device to change in games and applications where dynamic device switching is used, for example when the \href{../api/UnityEngine.InputSystem.PlayerInput.html}{\texttt{ {\ttfamily Player\+Input}}} component is used with the \href{../api/UnityEngine.InputSystem.PlayerInput.html\#UnityEngine_InputSystem_PlayerInput_neverAutoSwitchControlSchemes}{\texttt{ {\ttfamily Player\+Input.\+never\+Auto\+Switch\+Control\+Schemes}}}) propety set to false. As the stick is dragged around, the paired device will alternate between the device that owns the pointer (mouse, touch, pen etc) and the device from the control path, which can result in jittery movement of the on-\/screen stick.

Use Isolated Input Actions to fix this. This mode uses a local set of Input Action instances to drive interaction with the stick, and not the actions defined in the UI. The downside of this mode is that pointer actions will be duplicated in both the on-\/screen stick component and any Input Action Assets being used to drive the UI. Note that if a set of bindings is not specified for the Pointer Down Action and Pointer Move Actions, the following defaults will be used\+:


\begin{DoxyItemize}
\item Pointer Down Action
\begin{DoxyItemize}
\item {\ttfamily \texorpdfstring{$<$}{<}Mouse\texorpdfstring{$>$}{>}/left\+Button}
\item {\ttfamily \texorpdfstring{$<$}{<}Pen\texorpdfstring{$>$}{>}/tip}
\item {\ttfamily \texorpdfstring{$<$}{<}Touchscreen\texorpdfstring{$>$}{>}/touch\texorpdfstring{$\ast$}{*}/press}
\item {\ttfamily \texorpdfstring{$<$}{<}XRController\texorpdfstring{$>$}{>}/trigger}
\end{DoxyItemize}
\item Pointer Move Action
\begin{DoxyItemize}
\item {\ttfamily \texorpdfstring{$<$}{<}Mouse\texorpdfstring{$>$}{>}/position}
\item {\ttfamily \texorpdfstring{$<$}{<}Pen\texorpdfstring{$>$}{>}/position}
\item {\ttfamily \texorpdfstring{$<$}{<}Touchscreen\texorpdfstring{$>$}{>}/touch\texorpdfstring{$\ast$}{*}/position}
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_on_screen_autotoc_md1502}{}\doxysection{\texorpdfstring{Writing custom on-\/screen Controls}{Writing custom on-\/screen Controls}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_on_screen_autotoc_md1502}
You can add support for new types of \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_controls}{Input Controls}{0} by extending \href{../api/UnityEngine.InputSystem.OnScreen.OnScreenControl.html}{\texttt{ {\ttfamily On\+Screen\+Control}}}. An easy example to follow is \href{../api/UnityEngine.InputSystem.OnScreen.OnScreenButton.html}{\texttt{ {\ttfamily On\+Screen\+Button}}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{[AddComponentMenu(\textcolor{stringliteral}{"{}Input/On-\/Screen\ Button"{}})]}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keyword}{class\ }OnScreenButton\ :\ OnScreenControl,\ IPointerDownHandler,\ IPointerUpHandler}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ \textcolor{keywordtype}{void}\ OnPointerUp(PointerEventData\ data)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ SendValueToControl(0.0f);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ \textcolor{keywordtype}{void}\ OnPointerDown(PointerEventData\ data)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ SendValueToControl(1.0f);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ [InputControl(layout\ =\ \textcolor{stringliteral}{"{}Button"{}})]}
\DoxyCodeLine{\ \ \ \ [SerializeField]}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{private}\ \textcolor{keywordtype}{string}\ m\_ControlPath;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{protected}\ \textcolor{keyword}{override}\ \textcolor{keywordtype}{string}\ controlPathInternal}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{get}\ =>\ m\_ControlPath;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{set}\ =>\ m\_ControlPath\ =\ value;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
 