\chapter{Memory aliasing}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing}{}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing}\index{Memory aliasing@{Memory aliasing}}
\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing_autotoc_md282}%
\Hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing_autotoc_md282}%
 Memory aliasing is a way to tell \doxylink{namespace_burst}{Burst} how your code uses data. This can improve and optimize the performance of your application.

Memory aliasing happens when locations in the memory overlap each other. The following documentation outlines the difference between memory aliasing, and no memory aliasing. ~\newline


The following example shows a job that copies data from an input array to an output array\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{[BurstCompile]}
\DoxyCodeLine{\textcolor{keyword}{private}\ \textcolor{keyword}{struct\ }CopyJob\ :\ IJob}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ [\mbox{\hyperlink{namespace_unity_editor_1_1_timeline_af9aefa8b1ec710da91fbc7bdf0bcafbca131fb182a881796e7606ed6da27f1197}{ReadOnly}}]}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ NativeArray<float>\ Input;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ [WriteOnly]}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ NativeArray<float>\ Output;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ \textcolor{keywordtype}{void}\ Execute()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ i\ =\ 0;\ i\ <\ Input.Length;\ i++)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ Output[i]\ =\ Input[i];}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
 \hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing_autotoc_md283}{}\doxysection{\texorpdfstring{No memory aliasing}{No memory aliasing}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing_autotoc_md283}
If the arrays {\ttfamily Input} and {\ttfamily Output} don\textquotesingle{}t overlap, which means that their respective memory location doesn\textquotesingle{}t overlap, the code returns the following result after running this job on a sample input/output\+:

{\itshape Memory with no aliasing}

If \doxylink{namespace_burst}{Burst} is \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing-noalias}{noalias}{0} aware, it can work at the scalar level to optimize the previous scalar loop. It does this through a process called vectorizing, where it rewrites the loop to process elements in a small batch. For example, \doxylink{namespace_burst}{Burst} could work at vector level in 4 by 4 elements\+:

~\newline
{\itshape Memory with no aliasing vectorized}\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing_autotoc_md284}{}\doxysection{\texorpdfstring{Memory aliasing}{Memory aliasing}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing_autotoc_md284}
If the {\ttfamily Output} array overlaps the {\ttfamily Input} array by one element (for example {\ttfamily Output\mbox{[}0\mbox{]}} points to {\ttfamily Input\mbox{[}1\mbox{]}}), then this means that the memory is aliasing. This gives the following result when you run {\ttfamily Copy\+Job} without the auto vectorizer\+:

~\newline
{\itshape Memory with aliasing}

If \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing-noalias}{Burst isn\textquotesingle{}t aware of the memory aliasing}{0}, it tries to auto vectorize the loop, which results in the following\+:

~\newline
{\itshape Memory with aliasing and invalid vectorized code}

The result of this code is invalid and might lead to bugs if \doxylink{namespace_burst}{Burst} can\textquotesingle{}t identify them.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing_autotoc_md285}{}\doxysection{\texorpdfstring{Generated code}{Generated code}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing_autotoc_md285}
In the {\ttfamily Copy\+Job} example, there is an {\ttfamily x64} assembly targeted at {\ttfamily AVX2} in its loop. The instruction {\ttfamily vmovups} moves 8 floats, so a single auto vectorized loop moves 4 Ã— 8 floats, which equals 32 floats copied per loop iteration, instead of just one\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ 86asm}
\DoxyCodeLine{.LBB0\_4:}
\DoxyCodeLine{\ \ \ \ vmovups\ ymm0,\ ymmword\ ptr\ [rcx\ -\/\ 96]}
\DoxyCodeLine{\ \ \ \ vmovups\ ymm1,\ ymmword\ ptr\ [rcx\ -\/\ 64]}
\DoxyCodeLine{\ \ \ \ vmovups\ ymm2,\ ymmword\ ptr\ [rcx\ -\/\ 32]}
\DoxyCodeLine{\ \ \ \ vmovups\ ymm3,\ ymmword\ ptr\ [rcx]}
\DoxyCodeLine{\ \ \ \ vmovups\ ymmword\ ptr\ [rdx\ -\/\ 96],\ ymm0}
\DoxyCodeLine{\ \ \ \ vmovups\ ymmword\ ptr\ [rdx\ -\/\ 64],\ ymm1}
\DoxyCodeLine{\ \ \ \ vmovups\ ymmword\ ptr\ [rdx\ -\/\ 32],\ ymm2}
\DoxyCodeLine{\ \ \ \ vmovups\ ymmword\ ptr\ [rdx],\ ymm3}
\DoxyCodeLine{\ \ \ \ sub\ \ \ \ \ rdx,\ -\/128}
\DoxyCodeLine{\ \ \ \ sub\ \ \ \ \ rcx,\ -\/128}
\DoxyCodeLine{\ \ \ \ add\ \ \ \ \ rsi,\ -\/32}
\DoxyCodeLine{\ \ \ \ jne\ \ \ \ \ .LBB0\_4}
\DoxyCodeLine{\ \ \ \ test\ \ \ \ r10d,\ r10d}
\DoxyCodeLine{\ \ \ \ je\ \ \ \ \ \ .LBB0\_8}

\end{DoxyCode}


The following example shows the same \doxylink{namespace_burst}{Burst} compiled loop, but \doxylink{namespace_burst}{Burst}\textquotesingle{}s aliasing is artificially disabled\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ 86asm}
\DoxyCodeLine{.LBB0\_2:}
\DoxyCodeLine{\ \ \ \ mov\ \ \ \ \ r8,\ qword\ ptr\ [rcx]}
\DoxyCodeLine{\ \ \ \ mov\ \ \ \ \ rdx,\ qword\ ptr\ [rcx\ +\ 16]}
\DoxyCodeLine{\ \ \ \ cdqe}
\DoxyCodeLine{\ \ \ \ mov\ \ \ \ \ edx,\ dword\ ptr\ [rdx\ +\ 4*rax]}
\DoxyCodeLine{\ \ \ \ mov\ \ \ \ \ dword\ ptr\ [r8\ +\ 4*rax],\ edx}
\DoxyCodeLine{\ \ \ \ inc\ \ \ \ \ eax}
\DoxyCodeLine{\ \ \ \ cmp\ \ \ \ \ eax,\ dword\ ptr\ [rcx\ +\ 8]}
\DoxyCodeLine{\ \ \ \ jl\ \ \ \ \ \ .LBB0\_2}

\end{DoxyCode}


The result is entirely scalar and runs approximately 32 times slower than the highly optimized, vectorized variant that the original alias analysis produces.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing_autotoc_md286}{}\doxysection{\texorpdfstring{Function cloning}{Function cloning}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing_autotoc_md286}
For function calls where \doxylink{namespace_burst}{Burst} knows about the aliasing between parameters to the function, \doxylink{namespace_burst}{Burst} can infer the aliasing. It can then propagate this onto the called function to improve optimization\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{[MethodImpl(MethodImplOptions.NoInlining)]}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ Bar(ref\ \textcolor{keywordtype}{int}\ a,\ ref\ \textcolor{keywordtype}{int}\ b)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ a\ =\ 42;}
\DoxyCodeLine{\ \ \ \ b\ =\ 13;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ a;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ Foo()}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ var\ a\ =\ 53;}
\DoxyCodeLine{\ \ \ \ var\ b\ =\ -\/2;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ Bar(ref\ a,\ ref\ b);}
\DoxyCodeLine{\}}

\end{DoxyCode}


The assembly for {\ttfamily Bar} would be\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ 86asm}
\DoxyCodeLine{mov\ \ \ \ \ dword\ ptr\ [rcx],\ 42}
\DoxyCodeLine{mov\ \ \ \ \ dword\ ptr\ [rdx],\ 13}
\DoxyCodeLine{mov\ \ \ \ \ eax,\ dword\ ptr\ [rcx]}
\DoxyCodeLine{ret}

\end{DoxyCode}


This is because \doxylink{namespace_burst}{Burst} doesn\textquotesingle{}t know the aliasing of {\ttfamily a} and {\ttfamily b} within the {\ttfamily Bar} function. This is in line with what other compiler technologies do with this code snippet.

\doxylink{namespace_burst}{Burst} is smarter than this though. Through a process of function cloning, \doxylink{namespace_burst}{Burst} creates a copy of {\ttfamily Bar} where it knows that the aliasing properties of {\ttfamily a} and {\ttfamily b} don\textquotesingle{}t alias. It then replaces the original call to {\ttfamily Bar} with a call to the copy. This results in the following assembly\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ 86asm}
\DoxyCodeLine{mov\ \ \ \ \ dword\ ptr\ [rcx],\ 42}
\DoxyCodeLine{mov\ \ \ \ \ dword\ ptr\ [rdx],\ 13}
\DoxyCodeLine{mov\ \ \ \ \ eax,\ 42}
\DoxyCodeLine{ret}

\end{DoxyCode}


In this scenario, \doxylink{namespace_burst}{Burst} doesn\textquotesingle{}t perform the second load from {\ttfamily a}.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing_autotoc_md287}{}\doxysection{\texorpdfstring{Aliasing checks}{Aliasing checks}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing_autotoc_md287}
Because aliasing is key to \doxylink{namespace_burst}{Burst}\textquotesingle{}s ability to optimize for performance, there are some aliasing intrinsics\+:


\begin{DoxyItemize}
\item \href{xref:Unity.Burst.CompilerServices.Aliasing.ExpectAliased*}{\texttt{ {\ttfamily Unity.\+Burst.\+Compiler\+Services.\+Aliasing.\+Expect\+Aliased}}} expects that the two pointers do alias, and generates a compiler error if not.
\item \href{xref:Unity.Burst.CompilerServices.Aliasing.ExpectNotAliased*}{\texttt{ {\ttfamily Unity.\+Burst.\+Compiler\+Services.\+Aliasing.\+Expect\+Not\+Aliased}}} expects that the two pointers don\textquotesingle{}t alias, and generates a compiler error if not.
\end{DoxyItemize}

An example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{\textcolor{keyword}{using\ }static\ \mbox{\hyperlink{namespace_unity}{Unity}}.\mbox{\hyperlink{namespace_unity_1_1_burst}{Burst}}.\mbox{\hyperlink{namespace_unity_1_1_burst_1_1_compiler_services}{CompilerServices}}.\mbox{\hyperlink{class_unity_1_1_burst_1_1_compiler_services_1_1_aliasing}{Aliasing}};}
\DoxyCodeLine{}
\DoxyCodeLine{[BurstCompile]}
\DoxyCodeLine{\textcolor{keyword}{private}\ \textcolor{keyword}{struct\ }CopyJob\ :\ IJob}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ [\mbox{\hyperlink{namespace_unity_editor_1_1_timeline_af9aefa8b1ec710da91fbc7bdf0bcafbca131fb182a881796e7606ed6da27f1197}{ReadOnly}}]}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ NativeArray<float>\ Input;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ [WriteOnly]}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ NativeArray<float>\ Output;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ unsafe\ \textcolor{keywordtype}{void}\ Execute()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ NativeContainer\ attributed\ structs\ (like\ NativeArray)\ cannot\ alias\ with\ each\ other\ in\ a\ job\ struct!}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ExpectNotAliased(Input.getUnsafePtr(),\ Output.getUnsafePtr());}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ NativeContainer\ structs\ cannot\ appear\ in\ other\ NativeContainer\ structs.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ExpectNotAliased(in\ Input,\ in\ Output);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ExpectNotAliased(in\ Input,\ Input.getUnsafePtr());}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ExpectNotAliased(in\ Input,\ Output.getUnsafePtr());}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ExpectNotAliased(in\ Output,\ Input.getUnsafePtr());}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ExpectNotAliased(in\ Output,\ Output.getUnsafePtr());}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ But\ things\ definitely\ alias\ with\ themselves!}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ExpectAliased(in\ Input,\ in\ Input);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ExpectAliased(Input.getUnsafePtr(),\ Input.getUnsafePtr());}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ExpectAliased(in\ Output,\ in\ Output);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ExpectAliased(Output.getUnsafePtr(),\ Output.getUnsafePtr());}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


These checks only run when optimizations are enabled, because proper aliasing deduction is intrinsically linked to the optimizer\textquotesingle{}s ability to see through functions via inlining. 