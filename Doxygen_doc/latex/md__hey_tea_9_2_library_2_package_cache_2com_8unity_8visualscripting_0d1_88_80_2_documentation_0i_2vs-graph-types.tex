\chapter{Graphs}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8visualscripting_0d1_88_80_2_documentation_0i_2vs-graph-types}{}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8visualscripting_0d1_88_80_2_documentation_0i_2vs-graph-types}\index{Graphs@{Graphs}}
\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8visualscripting_0d1_88_80_2_documentation_0i_2vs-graph-types_autotoc_md5369}%
\Hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8visualscripting_0d1_88_80_2_documentation_0i_2vs-graph-types_autotoc_md5369}%
 A graph is a Visual Scripting asset that contains a visual representation of logic in an application.

Visual Scripting has two different types of graphs\+: Script Graphs and State Graphs. You can use either graph type in specific situations to define and change how Game\+Objects in an application behave. Script Graphs and State Graphs must be attached to a Script Machine or State Machine to be used in a project. For more information on Script Machines and State Machines, see \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8visualscripting_0d1_88_80_2_documentation_0i_2vs-graph-machine-types}{Script Machines and State Machines}{0}.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8visualscripting_0d1_88_80_2_documentation_0i_2vs-graph-types_autotoc_md5370}{}\doxysection{\texorpdfstring{Script Graphs}{Script Graphs}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8visualscripting_0d1_88_80_2_documentation_0i_2vs-graph-types_autotoc_md5370}
Script Graphs control and connect specific actions and values. The actions in a Script Graph happen in a specific order. Actions can happen every frame, or when a specific event occurs.



Visual Scripting represents the actions in a Script Graph through \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8visualscripting_0d1_88_80_2_documentation_0i_2vs-nodes}{nodes}{0}. Connect nodes together with edges to tell your application what to do, and in what order.

Script Graphs can access a large collection of nodes, which correspond to different features and functionality in the \doxylink{namespace_unity}{Unity} Editor. Access these nodes through \href{vs-interface-overview.md\#the-fuzzy-finder}{\texttt{ the fuzzy finder}}.

Script Graphs define the specifics of what a Game\+Object does while your application runs.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8visualscripting_0d1_88_80_2_documentation_0i_2vs-graph-types_autotoc_md5371}{}\doxysection{\texorpdfstring{State Graphs}{State Graphs}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8visualscripting_0d1_88_80_2_documentation_0i_2vs-graph-types_autotoc_md5371}
A State Graph has states and gives the logic for when your application moves between states, through connections called transitions. Use State Graphs to design AI behavior or define scene and level structures.

A state is any set of behaviors that you want a Game\+Object to perform, represented as a Script Graph. Visual Scripting represents states in State Graphs through State nodes. A State node can link to a Script Graph with logic for your application to follow, or give another State Graph with additional transitions and State nodes.



States and transitions in a State Graph tell your application when to change its behavior, based on an event or after it fulfills a condition.

For example, you might have an enemy character with Patrol and Chase states. The enemy character\textquotesingle{}s actions can change from the actions in the Script Graph for the Patrol state to the actions for the Chase state after it detects the player character. The detection event for the enemy character triggers the transition between the two states.

State Graphs don\textquotesingle{}t use the fuzzy finder. They use a specific set of State nodes, which are in the Visual Scripting context menu\+:


\begin{DoxyItemize}
\item Script States contain a Script Graph. When an application triggers a Script State, Visual Scripting runs the logic in a Script State\textquotesingle{}s attached Script Graph. Script States use On Enter State Event, On Update Event, and On Exit State Event nodes to control logic based on the current state.
\item Super States contain another, nested State Graph. A Super State can help you better organize a State Graph, and reuse states and transitions across multiple graphs.
\item Any States serve as a placeholder for any other state in a State Graph. You can use an Any State node and create a single transition to a new state, rather than create multiple transitions from other states.
\item Transitions connect Script States, Any States, and Super States. Transitions contain Script Graphs that tell your application when to switch from one state to the next. For more information, see \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8visualscripting_0d1_88_80_2_documentation_0i_2vs-transitions}{Transitions}{0}.
\end{DoxyItemize}

You can set any Script State node or Super State node as a Start State. Any state marked as a Start State is automatically active when Visual Scripting runs a State Graph. You can also have multiple Start States in a single graph. The Super State, Start, and Script State nodes in the following example are all Start States.

 