\chapter{UI support}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support}{}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support}\index{UI support@{UI support}}
\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support_autotoc_md1586}%
\Hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support_autotoc_md1586}%

\begin{DoxyItemize}
\item Setting up UI Input
\begin{DoxyItemize}
\item How the bindings work
\begin{DoxyItemize}
\item Pointer-\/type input
\item Navigation-\/type input
\item Tracked-\/type input
\end{DoxyItemize}
\end{DoxyItemize}
\item Multiplayer UIs
\item Virtual mouse cursor control
\item UI and game input
\item UI Toolkit support
\end{DoxyItemize}

You can use the Input \doxylink{namespace_system}{System} package to control any in-\/game UI created with the \href{https://docs.unity3d.com/Manual/UISystem.html}{\texttt{ Unity UI package}}. The integration between the Input \doxylink{namespace_system}{System} and the UI system is handled by the \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html}{\texttt{ Input\+System\+UIInput\+Module}} component.

\texorpdfstring{$>$}{>}\mbox{[}!\+NOTE\mbox{]} \texorpdfstring{$>$}{>}The Input \doxylink{namespace_system}{System} package does not support IMGUI. If you have {\ttfamily On\+GUI} methods in your player code (Editor code is unaffected), \doxylink{namespace_unity}{Unity} does not receive any input events in those methods when the {\bfseries{Active Input Handling}} \href{https://docs.unity3d.com/Manual/class-PlayerSettings.html}{\texttt{ Player Setting}} is set to {\bfseries{Input \doxylink{namespace_system}{System} Package}}. To restore functionality you can change the setting to {\bfseries{Both}}, but this means that \doxylink{namespace_unity}{Unity} processes the input twice.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support_autotoc_md1587}{}\doxysection{\texorpdfstring{Setting up UI input}{Setting up UI input}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support_autotoc_md1587}
The \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html}{\texttt{ Input\+System\+UIInput\+Module}} component acts as a drop-\/in replacement for the \href{https://docs.unity3d.com/Manual/script-StandaloneInputModule.html}{\texttt{ Standalone\+Input\+Module}} component that the \doxylink{namespace_unity}{Unity} UI package. \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html}{\texttt{ Input\+System\+UIInput\+Module}} provides the same functionality as \href{https://docs.unity3d.com/Manual/script-StandaloneInputModule.html}{\texttt{ Standalone\+Input\+Module}}, but it uses the Input \doxylink{namespace_system}{System} instead of the legacy Input Manager to drive UI input.

If you have a \href{https://docs.unity3d.com/Manual/script-StandaloneInputModule.html}{\texttt{ Standalone\+Input\+Module}} component on a Game\+Object, and the Input \doxylink{namespace_system}{System} is installed, \doxylink{namespace_unity}{Unity} shows a button in the Inspector offering to automatically replace it with a \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html}{\texttt{ Input\+System\+UIInput\+Module}} for you. The \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html}{\texttt{ Input\+System\+UIInput\+Module}} is pre-\/configured to use default Input Actions to drive the UI, but you can override that configuration to suit your needs.



You can use the following properties to configure \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html}{\texttt{ Input\+System\+UIInput\+Module}}\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Property}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Property}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}    }\\\cline{1-2}
\endhead
\href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_moveRepeatDelay}{\texttt{ Move Repeat Delay}}   &The initial delay (in seconds) between generating an initial \href{https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.IMoveHandler.html}{\texttt{ IMove\+Handler.\+On\+Move}} navigation event and generating repeated navigation events when the {\bfseries{Move}} Action stays actuated.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_moveRepeatDelay}{\texttt{ Move Repeat Rate}}   &The interval (in seconds) between generating repeat navigation events when the {\bfseries{Move}} Action stays actuated. Note that this is capped by the frame rate; there will not be more than one move repeat event each frame so if the frame rate dips below the repeat rate, the effective repeat rate will be lower than this setting.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_actionsAsset}{\texttt{ Actions Asset}}   &An \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_action_assets}{Input Action Asset}{0} containing all the Actions to control the UI. You can choose which Actions in the Asset correspond to which UI inputs using the following properties.~\newline
~\newline
By default, this references a built-\/in Asset named {\itshape Default\+Input\+Actions}, which contains common default Actions for driving UI. If you want to set up your own Actions, \href{ActionAssets.md\#creating-input-action-assets}{\texttt{ create a custom Input Action Asset}} and assign it here. When you assign a new Asset reference to this field in the Inspector, the Editor attempts to automatically map Actions to UI inputs based on common naming conventions.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_deselectOnBackgroundClick}{\texttt{ Deselect on Background Click}}   &By default, when the pointer is clicked and does not hit any {\ttfamily Game\+Object}, the current selection is cleared. This, however, can get in the way of keyboard and gamepad navigation which will want to work off the currently selected object. To prevent automatic deselection, set this property to false.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_pointerBehavior}{\texttt{ Pointer Behavior}}   &How to deal with multiple pointers feeding input into the UI. See pointer-\/type input.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_cursorLockBehavior}{\texttt{ Cursor Lock Behavior}}   &Controls the origin point of UI raycasts when the cursor is locked.   \\\cline{1-2}
\end{longtabu}


You can use the following properties to map Actions from the chosen \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_actionsAsset}{\texttt{ {\bfseries{Actions Asset}}}} to UI input Actions. In the Inspector, these appear as foldout lists that contain all the Actions in the Asset\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Property}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Property}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}    }\\\cline{1-2}
\endhead
\href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_point}{\texttt{ Point}}   &An Action that delivers a 2D screen position. Use as a cursor for pointing at UI elements to implement mouse-\/style UI interactions. See pointer-\/type input.~\newline
~\newline
Set to \href{../api/UnityEngine.InputSystem.InputActionType.html\#UnityEngine_InputSystem_InputActionType_PassThrough}{\texttt{ Pass\+Through}} Action type and {\ttfamily Vector2} value type.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_leftClick}{\texttt{ Left Click}}   &An Action that maps to the primary cursor button used to interact with UI. See pointer-\/type input.~\newline
~\newline
Set to \href{../api/UnityEngine.InputSystem.InputActionType.html\#UnityEngine_InputSystem_InputActionType_PassThrough}{\texttt{ Pass\+Through}} Action type and {\ttfamily Button} value type.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_middleClick}{\texttt{ Middle Click}}   &An Action that maps to the middle cursor button used to interact with UI. See pointer-\/type input.~\newline
~\newline
Set to \href{../api/UnityEngine.InputSystem.InputActionType.html\#UnityEngine_InputSystem_InputActionType_PassThrough}{\texttt{ Pass\+Through}} Action type and {\ttfamily Button} value type.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_rightClick}{\texttt{ Right Click}}   &An Action that maps to the secondary cursor button used to interact with UI. See pointer-\/type input.~\newline
~\newline
Set to \href{../api/UnityEngine.InputSystem.InputActionType.html\#UnityEngine_InputSystem_InputActionType_PassThrough}{\texttt{ Pass\+Through}} Action type and {\ttfamily Button} value type.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_scrollWheel}{\texttt{ Scroll Wheel}}   &An Action that delivers gesture input to allow scrolling in the UI. See pointer-\/type input.~\newline
~\newline
Set to \href{../api/UnityEngine.InputSystem.InputActionType.html\#UnityEngine_InputSystem_InputActionType_PassThrough}{\texttt{ Pass\+Through}} Action type and {\ttfamily Vector2} value type.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_move}{\texttt{ Move}}   &An Action that delivers a 2D vector used to select the currently active UI \href{https://docs.unity3d.com/Manual/script-Selectable.html}{\texttt{ selectable}}. This allows a gamepad or arrow-\/key style navigation of the UI. See navigation-\/type input.~\newline
~\newline
Set to \href{../api/UnityEngine.InputSystem.InputActionType.html\#UnityEngine_InputSystem_InputActionType_PassThrough}{\texttt{ Pass\+Through}} Action type and {\ttfamily Vector2} value type.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_submit}{\texttt{ Submit}}   &An Action to engage with or "{}click"{} the currently selected UI \href{https://docs.unity3d.com/Manual/script-Selectable.html}{\texttt{ selectable}}. See navigation-\/type input.~\newline
~\newline
Set to \href{../api/UnityEngine.InputSystem.InputActionType.html\#UnityEngine_InputSystem_InputActionType_Button}{\texttt{ Button}} Action type.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_cancel}{\texttt{ Cancel}}   &An Action to exit any interaction with the currently selected UI \href{https://docs.unity3d.com/Manual/script-Selectable.html}{\texttt{ selectable}}. See navigation-\/type input.~\newline
~\newline
Set to \href{../api/UnityEngine.InputSystem.InputActionType.html\#UnityEngine_InputSystem_InputActionType_Button}{\texttt{ Button}} Action type.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_trackedDevicePosition}{\texttt{ Tracked Device Position}}   &An Action that delivers a 3D position of one or multiple spatial tracking devices, such as XR hand controllers. In combination with \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_trackedDeviceOrientation}{\texttt{ Tracked Device Orientation}}, this allows XR-\/style UI interactions by pointing at UI \href{https://docs.unity3d.com/Manual/script-Selectable.html}{\texttt{ selectables}} in space. See tracked-\/type input.~\newline
~\newline
Set to \href{../api/UnityEngine.InputSystem.InputActionType.html\#UnityEngine_InputSystem_InputActionType_PassThrough}{\texttt{ Pass\+Through}} Action type and {\ttfamily Vector3} value type.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_trackedDeviceOrientation}{\texttt{ Tracked Device Orientation}}   &An Action that delivers a {\ttfamily Quaternion} representing the rotation of one or multiple spatial tracking devices, such as XR hand controllers. In combination with \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_trackedDevicePosition}{\texttt{ Tracked Device Position}}, this allows XR-\/style UI interactions by pointing at UI \href{https://docs.unity3d.com/Manual/script-Selectable.html}{\texttt{ selectables}} in space. See tracked-\/type input.~\newline
~\newline
Set to \href{../api/UnityEngine.InputSystem.InputActionType.html\#UnityEngine_InputSystem_InputActionType_PassThrough}{\texttt{ Pass\+Through}} Action type and {\ttfamily Quaternion} value type.   \\\cline{1-2}
\end{longtabu}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support_autotoc_md1588}{}\doxysubsection{\texorpdfstring{How the bindings work}{How the bindings work}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support_autotoc_md1588}
The UI input module can deal with three different types of input\+:


\begin{DoxyEnumerate}
\item pointer-\/type input,
\item navigation-\/type input, and
\item tracked-\/type input.
\end{DoxyEnumerate}

For each of these types of input, input is sourced and combined from a specific set of Actions as detailed below.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support_autotoc_md1589}{}\doxysubsubsection{\texorpdfstring{Pointer-\/type input}{Pointer-\/type input}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support_autotoc_md1589}
To the UI, a pointer is a position from which clicks and scrolls can be triggered to interact with UI elements at the pointer\textquotesingle{}s position. Pointer-\/type input is sourced from \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_point}{\texttt{ point}}, \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_leftClick}{\texttt{ left\+Click}}, \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_rightClick}{\texttt{ right\+Click}}, \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_middleClick}{\texttt{ middle\+Click}}, and \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_scrollWheel}{\texttt{ scroll\+Wheel}}.

\texorpdfstring{$>$}{>}\mbox{[}!\+NOTE\mbox{]} \texorpdfstring{$>$}{>}The UI input module does not have an association between pointers and cursors. In general, the UI is oblivious to whether a cursor exists for a particular pointer. However, for mouse and pen input, the UI input module will respect \href{https://docs.unity3d.com/ScriptReference/Cursor-lockState.html}{\texttt{ Cusor.\+lock\+State}} and pin the pointer position at {\ttfamily (-\/1,-\/1)} whenever the cursor is locked. This behavior can be changed through the \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_cursorLockBehavior}{\texttt{ Cursor Lock Behavior}} property of the \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html}{\texttt{ Input\+System\+UIInput\+Module}}.

Multiple pointer Devices may feed input into a single UI input module. Also, in the case of \href{../api/UnityEngine.InputSystem.Touchscreen.html}{\texttt{ Touchscreen}}, a single Device can have the ability to have multiple concurrent pointers (each finger contact is one pointer).

\texorpdfstring{$>$}{>}\mbox{[}!\+IMPORTANT\mbox{]} \texorpdfstring{$>$}{>}Because multiple pointer Devices can feed into the same set of Actions, it is important to set the \href{./Actions.md\#action-types}{\texttt{ action type}} to \href{../api/UnityEngine.InputSystem.InputActionType.html\#UnityEngine_InputSystem_InputActionType_PassThrough}{\texttt{ Pass\+Through}}. This ensures that no filtering is applied to input on these actions and that instead every input is relayed as is.

From the perspective of \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html}{\texttt{ Input\+System\+UIInput\+Module}}, each \href{../api/UnityEngine.InputSystem.InputDevice.html}{\texttt{ Input\+Device}} that has one or more controls bound to one of the pointer-\/type actions is considered a unique pointer. Also, for each \href{../api/UnityEngine.InputSystem.Touchscreen.html}{\texttt{ Touchscreen}} devices, each separate \href{../api/UnityEngine.InputSystem.Controls.TouchControl.html}{\texttt{ Touch\+Control}} that has one or more of its controls bound to the those actions is considered its own unique pointer as well. Each pointer receives a unique \href{https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.PointerEventData.html\#UnityEngine_EventSystems_PointerEventData_pointerId}{\texttt{ pointer\+Id}} which generally corresponds to the \href{../api/UnityEngine.InputSystem.InputDevice.html\#UnityEngine_InputSystem_InputDevice_deviceId}{\texttt{ device\+Id}} of the pointer. However, for touch, this will be a combination of \href{../api/UnityEngine.InputSystem.InputDevice.html\#UnityEngine_InputSystem_InputDevice_deviceId}{\texttt{ device\+Id}} and \href{../api/UnityEngine.InputSystem.Controls.TouchControl.html\#UnityEngine_InputSystem_Controls_TouchControl_touchId}{\texttt{ touch\+Id}}. Use \href{../api/UnityEngine.InputSystem.UI.ExtendedPointerEventData.html\#UnityEngine_InputSystem_UI_ExtendedPointerEventData_touchId}{\texttt{ Extended\+Pointer\+Event\+Data.\+touch\+Id}} to find the ID for a touch event.

You can influence how the input module deals with concurrent input from multiple pointers using the \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_pointerBehavior}{\texttt{ Pointer Behavior}} setting.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Pointer Behavior}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Pointer Behavior}}   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{Description}}    }\\\cline{1-2}
\endhead
\href{../api/UnityEngine.InputSystem.UI.UIPointerBehavior.html\#UnityEngine_InputSystem_UI_UIPointerBehavior_SingleMouseOrPenButMultiTouchAndTrack}{\texttt{ Single Mouse or Pen But Multi Touch And Track}}   &Behaves like \href{../api/UnityEngine.InputSystem.UI.UIPointerBehavior.html\#UnityEngine_InputSystem_UI_UIPointerBehavior_SingleUnifiedPointer}{\texttt{ Single Unified Pointer}} for all input that is not classified as touch or tracked input, and behaves like \href{../api/UnityEngine.InputSystem.UI.UIPointerBehavior.html\#UnityEngine_InputSystem_UI_UIPointerBehavior_AllPointersAsIs}{\texttt{ All Pointers As Is}} for tracked and touch input.~\newline
~\newline
If concurrent input is received on a \href{../api/UnityEngine.InputSystem.Mouse.html}{\texttt{ Mouse}} and \href{../api/UnityEngine.InputSystem.Pen.html}{\texttt{ {\ttfamily Pen}}}, for example, the input of both is fed into the same UI pointer instance. The position input of one will overwrite the position of the other.~\newline
~\newline
Note that when input is received from touch or tracked devices, the single unified pointer for mice and pens is {\bfseries{removed}} including \href{https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.IPointerExitHandler.html}{\texttt{ IPointer\+Exit}} events being sent in case the mouse/pen cursor is currently hovering over objects.~\newline
~\newline
This is the default behavior.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.UI.UIPointerBehavior.html\#UnityEngine_InputSystem_UI_UIPointerBehavior_SingleUnifiedPointer}{\texttt{ Single Unified Pointer}}   &All pointer input is unified such that there is only ever a single pointer. This includes touch and tracked input. This means, for example, that regardless how many devices feed input into \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_point}{\texttt{ Point}}, only the last such input in a frame will take effect and become the current UI pointer\textquotesingle{}s position.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.UI.UIPointerBehavior.html\#UnityEngine_InputSystem_UI_UIPointerBehavior_AllPointersAsIs}{\texttt{ All Pointers As Is}}   &The UI input module will not unify any pointer input. Any device, including touch and tracked devices that feed input pointer-\/type actions, will be its own pointer (or multiple pointers for touch input).~\newline
~\newline
Note\+: This might mean that there will be an arbitrary number of pointers in the UI, and several objects might be pointed at concurrently.   \\\cline{1-2}
\end{longtabu}


\texorpdfstring{$>$}{>}\mbox{[}!\+NOTE\mbox{]} \texorpdfstring{$>$}{>}If you bind a device to a pointer-\/type action such as \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_leftClick}{\texttt{ Left Click}} without also binding it to \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_point}{\texttt{ Point}}, the UI input module will recognize the device as not being able to point and try to route its input into that of another pointer. For example, if you bind \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_leftClick}{\texttt{ Left Click}} to the {\ttfamily Space} key and \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_point}{\texttt{ Point}} to the position of the mouse, then pressing the space bar will result in a left click at the current position of the mouse.

For pointer-\/type input (as well as for tracked-\/type input), \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html}{\texttt{ Input\+System\+UIInput\+Module}} will send \href{../api/UnityEngine.InputSystem.UI.ExtendedPointerEventData.html}{\texttt{ Extended\+Pointer\+Event\+Data}} instances which are an extended version of the base {\ttfamily Pointer\+Event\+Data}. These events contain additional data such as the \href{../api/UnityEngine.InputSystem.UI.ExtendedPointerEventData.html\#UnityEngine_InputSystem_UI_ExtendedPointerEventData_device}{\texttt{ device}} and \href{../api/UnityEngine.InputSystem.UI.ExtendedPointerEventData.html\#UnityEngine_InputSystem_UI_ExtendedPointerEventData_pointerType}{\texttt{ pointer type}} which the event has been generated from.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support_autotoc_md1590}{}\doxysubsubsection{\texorpdfstring{Navigation-\/type input}{Navigation-\/type input}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support_autotoc_md1590}
Navigation-\/type input controls the current selection based on motion read from the \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_move}{\texttt{ move}} action. Additionally, input from \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_submit}{\texttt{ submit}} will trigger {\ttfamily ISubmit\+Handler} on the currently selected object and \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_cancel}{\texttt{ cancel}} will trigger {\ttfamily ICancel\+Handler} on it.

Unlike with pointer-\/type, where multiple pointer inputs may exist concurrently (think two touches or left-\/ and right-\/hand tracked input), navigation-\/type input does not have multiple concurrent instances. In other words, only a single \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_move}{\texttt{ move}} vector and a single \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_submit}{\texttt{ submit}} and \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_cancel}{\texttt{ cancel}} input will be processed by the UI module each frame. However, these inputs need not necessarily come from one single Device always. Arbitrary many inputs can be bound to the respective actions.

\texorpdfstring{$>$}{>}\mbox{[}!\+IMPORTANT\mbox{]} \texorpdfstring{$>$}{>}While, \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_move}{\texttt{ move}} should be set to \href{../api/UnityEngine.InputSystem.InputActionType.html\#UnityEngine_InputSystem_InputActionType_PassThrough}{\texttt{ Pass\+Through}} Action type, it is important that \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_submit}{\texttt{ submit}} and \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_cancel}{\texttt{ cancel}} be set to the \href{../api/UnityEngine.InputSystem.InputActionType.html\#UnityEngine_InputSystem_InputActionType_Button}{\texttt{ Button}} Action type.

Navigation input is non-\/positional, that is, unlike with pointer-\/type input, there is no screen position associcated with these actions. Rather, navigation actions always operate on the current selection.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support_autotoc_md1591}{}\doxysubsubsection{\texorpdfstring{Tracked-\/type input}{Tracked-\/type input}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support_autotoc_md1591}
Input from \href{../api/UnityEngine.InputSystem.TrackedDevice.html}{\texttt{ tracked devices}} such as \href{../api/UnityEngine.InputSystem.XR.XRController.html}{\texttt{ XR controllers}} and \href{../api/UnityEngine.InputSystem.XR.XRHMD.html}{\texttt{ HMDs}} essentially behaves like pointer-\/type input. The main difference is that the world-\/space device position and orientation sourced from \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_trackedDevicePosition}{\texttt{ tracked\+Device\+Position}} and \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_trackedDeviceOrientation}{\texttt{ tracked\+Device\+Orientation}} is translated into a screen-\/space position via raycasting.

\texorpdfstring{$>$}{>}\mbox{[}!\+IMPORTANT\mbox{]} \texorpdfstring{$>$}{>}Because multiple tracked Devices can feed into the same set of Actions, it is important to set the \href{./Actions.md\#action-types}{\texttt{ action type}} to \href{../api/UnityEngine.InputSystem.InputActionType.html\#UnityEngine_InputSystem_InputActionType_PassThrough}{\texttt{ Pass\+Through}}. This ensures that no filtering is applied to input on these actions and that instead every input is relayed as is.

For this raycasting to work, you need to add \href{../api/UnityEngine.InputSystem.UI.TrackedDeviceRaycaster.html}{\texttt{ Tracked\+Device\+Raycaster}} to the {\ttfamily Game\+Object} that has the UI\textquotesingle{}s {\ttfamily Canvas} component. This {\ttfamily Game\+Object} will usually have a {\ttfamily Graphic\+Raycaster} component which, however, only works for 2D screen-\/space raycasting. You can put \href{../api/UnityEngine.InputSystem.UI.TrackedDeviceRaycaster.html}{\texttt{ Tracked\+Device\+Raycaster}} alongside {\ttfamily Graphic\+Raycaster} and both can be enabled at the same time without advserse effect.





Clicks on tracked devices do not differ from other pointer-\/type input. Therefore, actions such as \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html\#UnityEngine_InputSystem_UI_InputSystemUIInputModule_leftClick}{\texttt{ Left Click}} work for tracked devices just like they work for other pointers.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support_autotoc_md1592}{}\doxysection{\texorpdfstring{Multiplayer UIs}{Multiplayer UIs}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support_autotoc_md1592}
The Input \doxylink{namespace_system}{System} can also handle multiple separate UI instances on the screen controlled separately from different input Bindings. This is useful if you want to have multiple local players share a single screen with different controllers, so that every player can control their own UI instance. To allow this, you need to replace the \href{https://docs.unity3d.com/Manual/script-EventSystem.html}{\texttt{ Event\+System}} component from \doxylink{namespace_unity}{Unity} with the Input \doxylink{namespace_system}{System}\textquotesingle{}s \href{../api/UnityEngine.InputSystem.UI.MultiplayerEventSystem.html}{\texttt{ Multiplayer\+Event\+System}} component.



Unlike the \href{https://docs.unity3d.com/Manual/script-EventSystem.html}{\texttt{ Event\+System}} component, you can have multiple \href{../api/UnityEngine.InputSystem.UI.MultiplayerEventSystem.html}{\texttt{ Multiplayer\+Event\+Systems}} active in the Scene at the same time. That way, you can have multiple players, each with their own \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html}{\texttt{ Input\+System\+UIInput\+Module}} and \href{../api/UnityEngine.InputSystem.UI.MultiplayerEventSystem.html}{\texttt{ Multiplayer\+Event\+System}} components, and each player can have their own set of Actions driving their own UI instance. If you are using the \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_player_input}{Player\+Input}{0} component, you can also set up \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_player_input}{Player\+Input}{0} to automatically configure the player\textquotesingle{}s \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html}{\texttt{ Input\+System\+UIInput\+Module}} to use the player\textquotesingle{}s Actions. See the documentation on \href{PlayerInput.md\#ui-input}{\texttt{ Player\+Input}} to learn how.

The properties of the \href{../api/UnityEngine.InputSystem.UI.MultiplayerEventSystem.html}{\texttt{ Multiplayer\+Event\+System}} component are identical with those from the \href{https://docs.unity3d.com/Manual/script-EventSystem.html}{\texttt{ Event System}}. Additionally, the \href{../api/UnityEngine.InputSystem.UI.MultiplayerEventSystem.html}{\texttt{ Multiplayer\+Event\+System}} component adds a \href{../api/UnityEngine.InputSystem.UI.MultiplayerEventSystem.html\#UnityEngine_InputSystem_UI_MultiplayerEventSystem_playerRoot}{\texttt{ player\+Root}} property, which you can set to a Game\+Object that contains all the UI \href{https://docs.unity3d.com/Manual/script-Selectable.html}{\texttt{ selectables}} this event system should handle in its hierarchy. Mouse input that this event system processes then ignores any UI selectables which are not on any Game\+Object in the Hierarchy under \href{../api/UnityEngine.InputSystem.UI.MultiplayerEventSystem.html\#UnityEngine_InputSystem_UI_MultiplayerEventSystem_playerRoot}{\texttt{ Player Root}}.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support_autotoc_md1593}{}\doxysection{\texorpdfstring{Virtual mouse cursor control}{Virtual mouse cursor control}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support_autotoc_md1593}
\texorpdfstring{$>$}{>}\mbox{[}!\+NOTE\mbox{]} \texorpdfstring{$>$}{>}While pointer input generated from a {\ttfamily Virtual\+Mouse\+Input} component is received in UI Toolkit, the {\ttfamily Virtual\+Mouse\+Input} component is not officially supported for use with UI Toolkit. At the moment, it only works in combination with the \href{https://docs.unity3d.com/Manual/com.unity.ugui.html}{\texttt{ Unity UI}} system.

If your application uses gamepads and joysticks as an input, you can use the navigation Actions to operate the UI. However, it usually involves extra work to make the UI work well with navigation. An alternative way to operate the UI is to allow gamepads and joysticks to drive the cursor from a "{}virtual mouse cursor"{}.

\texorpdfstring{$>$}{>}\mbox{[}!\+TIP\mbox{]} \texorpdfstring{$>$}{>}To see an example of a \href{../api/UnityEngine.InputSystem.UI.VirtualMouseInput.html}{\texttt{ Virtual\+Mouse\+Input}} setup, see the \href{Installation.md\#installing-samples}{\texttt{ Gamepad Mouse Cursor sample}} included with the Input \doxylink{namespace_system}{System} package.

To set this up, follow these steps\+:


\begin{DoxyEnumerate}
\item Create a UI {\ttfamily Game\+Object} with an {\ttfamily Image} component. This represents a software mouse cursor. Then, add it as a child of the {\ttfamily Canvas} that the cursor should operate on. Set the anchor position of the Game\+Object\textquotesingle{}s {\ttfamily Rect\+Transform} to the bottom left. Make it the last child of the {\ttfamily Canvas} so that the cursor draws on top of everything else.
\item Add a \href{../api/UnityEngine.InputSystem.UI.VirtualMouseInput.html}{\texttt{ Virtual\+Mouse\+Input}} component to the Game\+Object. Then, link the {\ttfamily Image} component to the {\ttfamily Cursor Graphic} property, and the {\ttfamily Rect\+Transform} of the cursor Game\+Object to the {\ttfamily Cursor Transform} property.
\item If you want the virtual mouse to control the system mouse cursor, set \href{../api/UnityEngine.InputSystem.UI.VirtualMouseInput.html\#UnityEngine_InputSystem_UI_VirtualMouseInput_cursorMode}{\texttt{ Cursor Mode}} to {\ttfamily Hardware Cursor If Available}. In this mode, the {\ttfamily Cursor Graphic} is hidden when a system {\ttfamily Mouse} is present and you use \href{../api/UnityEngine.InputSystem.Mouse.html\#UnityEngine_InputSystem_Mouse_WarpCursorPosition_UnityEngine_Vector2_}{\texttt{ Mouse.\+Warp\+Cursor\+Position}} to move the system mouse cursor instead of the software cursor. The transform linked through {\ttfamily Cursor Transform} is not updated in that case.
\item To configure the input to drive the virtual mouse, either add bindings on the various actions (such as {\ttfamily Stick Action}), or enable {\ttfamily Use Reference} and link existing actions from an {\ttfamily .inputactions} asset.
\end{DoxyEnumerate}

\texorpdfstring{$>$}{>}\mbox{[}!\+IMPORTANT\mbox{]} \texorpdfstring{$>$}{>}Make sure that the {\ttfamily Input\+System\+UIInput\+Module} on the UI\textquotesingle{}s {\ttfamily Event\+System} does not receive navigation input from the same devices that feed into {\ttfamily Virtual\+Mouse\+Input}. If, for example, {\ttfamily Virtual\+Mouse\+Input} is set up to receive input from gamepads, and {\ttfamily Move}, {\ttfamily Submit}, and {\ttfamily Cancel} on {\ttfamily Input\+System\+UIInput\+Module} are also linked to the gamepad, then the UI receives input from the gamepad on two channels.



At runtime, the component adds a virtual \href{../api/UnityEngine.InputSystem.Mouse.html}{\texttt{ Mouse}} device which the \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html}{\texttt{ Input\+System\+UIInput\+Module}} component picks up. The controls of the {\ttfamily Mouse} are fed input based on the actions configured on the \href{../api/UnityEngine.InputSystem.UI.VirtualMouseInput.html}{\texttt{ Virtual\+Mouse\+Input}} component.

Note that the resulting \href{../api/UnityEngine.InputSystem.Mouse.html}{\texttt{ Mouse}} input is visible in all code that picks up input from the mouse device. You can therefore use the component for mouse simulation elsewhere, not just with \href{../api/UnityEngine.InputSystem.UI.InputSystemUIInputModule.html}{\texttt{ Input\+System\+UIInput\+Module}}.

\texorpdfstring{$>$}{>}\mbox{[}!\+NOTE\mbox{]} \texorpdfstring{$>$}{>}Do not set up gamepads and joysticks for navigation input while using {\ttfamily Virtual\+Mouse\+Input}. If both {\ttfamily Virtual\+Mouse\+Input} and navigation are configured, input is triggered twice\+: once via the pointer input path, and once via the navigation input path. If you encounter problems such as where buttons are pressed twice, this is likely the problem.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support_autotoc_md1594}{}\doxysection{\texorpdfstring{UI and game input}{UI and game input}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support_autotoc_md1594}
\texorpdfstring{$>$}{>}\mbox{[}!\+NOTE\mbox{]} \texorpdfstring{$>$}{>}A sample called {\ttfamily UI vs Game Input} is provided with the package and can be installed from the \doxylink{namespace_unity}{Unity} Package Manager UI in the editor. The sample demonstrates how to deal with a situation where ambiguities arise between inputs for UI and inputs for the game.

UI in \doxylink{namespace_unity}{Unity} consumes input through the same mechanisms as game/player code. Right now, there is no mechanism that implicitly ensures that if a certain input -- such as a click -- is consumed by the UI, it is not also "{}consumed"{} by the game. This can create ambiguities between, for example, code that responds to \href{https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.UI.Button.html\#UnityEngine_UI_Button_onClick}{\texttt{ {\ttfamily UI.\+Button.\+on\+Click}}} and code that responds to \href{../api/UnityEngine.InputSystem.InputAction.html\#UnityEngine_InputSystem_InputAction_performed}{\texttt{ {\ttfamily Input\+Action.\+performed}}} of an Action bound to {\ttfamily \texorpdfstring{$<$}{<}Mouse\texorpdfstring{$>$}{>}/left\+Button}.

Whether such ambiguities exist depends on {\itshape how} UIs are used. In the following scenarios, ambiguities are avoided\+:


\begin{DoxyItemize}
\item All interaction is performed through UI elements. A 2D/3D scene is rendered in the background but all interaction is performed through UI events (including those such as \textquotesingle{}background\textquotesingle{} clicks on the {\ttfamily Canvas}).
\item UI is overlaid over a 2D/3D scene but the UI elements cannot be interacted with directly.
\item UI is overlaid over a 2D/3D scene but there is a clear "{}mode"{} switch that determines if interaction is picked up by UI or by the game. For example, a first-\/person game on desktop may employ a \href{https://docs.unity3d.com/ScriptReference/Cursor-lockState.html}{\texttt{ cursor lock}} and direct input to the game while it is engaged whereas it may leave all interaction to the UI while the lock is not engaged.
\end{DoxyItemize}

When ambiguities arise, they do so differently for pointer-\/type and navigation-\/type.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support_autotoc_md1595}{}\doxysubsection{\texorpdfstring{Handling ambiguities for pointer-\/type input}{Handling ambiguities for pointer-\/type input}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support_autotoc_md1595}
\texorpdfstring{$>$}{>}\mbox{[}!\+NOTE\mbox{]} \texorpdfstring{$>$}{>}Calling \href{https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.EventSystem.html?q=ispointerovergameobject\#UnityEngine_EventSystems_EventSystem_IsPointerOverGameObject}{\texttt{ {\ttfamily Event\+System.\+Is\+Pointer\+Over\+Game\+Object}}} from within \href{../api/UnityEngine.InputSystem.InputAction.html}{\texttt{ {\ttfamily Input\+Action}}} callbacks such as \href{../api/UnityEngine.InputSystem.InputAction.html\#UnityEngine_InputSystem_InputAction_performed}{\texttt{ {\ttfamily Input\+Action.\+performed}}} will lead to a warning. The UI updates separately {\itshape after} input processing and UI state thus corresponds to that of the {\itshape last} frame/update while input is being processed.

Input from pointers (mice, touchscreens, pens) can be ambiguous depending on whether or not the pointer is over a UI element when initiating an interaction. For example, if there is a button on screen, then clicking on the button may lead to a different outcome than clicking outside of the button and within the game scene.

If all pointer input is handled via UI events, no ambiguities arise as the UI will implicitly route input to the respective receiver. If, however, input within the UI is handled via UI events and input in the game is handled via \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_actions}{Actions}{0}, pointer input will by default lead to {\itshape both} being triggered.

The easiest way to resolve such ambiguities is to respond to in-\/game actions by \href{Actions.md\#polling-actions}{\texttt{ polling}} from inside \href{https://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html}{\texttt{ {\ttfamily Mono\+Behaviour.\+Update}}} methods and using \href{https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.EventSystem.html?q=ispointerovergameobject\#UnityEngine_EventSystems_EventSystem_IsPointerOverGameObject}{\texttt{ {\ttfamily Event\+System.\+Is\+Pointer\+Over\+Game\+Object}}} to find out whether the pointer is over UI or not. Another way is to use \href{https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.EventSystem.html?q=ispointerovergameobj\#UnityEngine_EventSystems_EventSystem_RaycastAll_UnityEngine_EventSystems_PointerEventData_System_Collections_Generic_List_UnityEngine_EventSystems_RaycastResult__}{\texttt{ {\ttfamily Event\+System.\+Raycast\+All}}} to determine if the pointer is currently over UI.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support_autotoc_md1596}{}\doxysubsection{\texorpdfstring{Handling ambiguities for navigation-\/type input}{Handling ambiguities for navigation-\/type input}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support_autotoc_md1596}
Ambiguities for navigation-\/type Devices such as gamepads and joysticks (but also keyboards) cannot arise the same way that it does for pointers. Instead, your application has to decide explicitly whether to use input for the UI\textquotesingle{}s {\ttfamily Move}, {\ttfamily Submit}, and {\ttfamily Cancel} inputs or for the game. This can be done by either splitting control on a Device or by having an explicit mode switch.

Splitting input on a Device is done by simply using certain controls for operating the UI while using others to operate the game. For example, you could use the d-\/pad on gamepads to operate UI selection while using the sticks for in-\/game character control. This setup requires adjusting the bindings used by the UI Actions accordingly.

An explicit mode switch is implemented by temporarily switching to UI control while suspending in-\/game Actions. For example, the left trigger on the gamepad could bring up an item selection wheel which then puts the game in a mode where the sticks are controlling UI selection, the A button confirms the selection, and the B button closes the item selection wheel. No ambiguities arise as in-\/game actions will not respond while the UI is in the "{}foreground"{}.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support_autotoc_md1597}{}\doxysection{\texorpdfstring{UI Toolkit support}{UI Toolkit support}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_u_i_support_autotoc_md1597}
As of \doxylink{namespace_unity}{Unity} 2021.\+2, \href{https://docs.unity3d.com/Manual/UIElements.html}{\texttt{ UI Toolkit}} is supported as an alternative to the \href{https://docs.unity3d.com/Manual/com.unity.ugui.html}{\texttt{ Unity UI}} system for implementing UIs in players.

Input support for both \href{https://docs.unity3d.com/Manual/com.unity.ugui.html}{\texttt{ Unity UI}} and \href{https://docs.unity3d.com/Manual/UIElements.html}{\texttt{ UI Toolkit}} is based on the same \href{https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/EventSystem.html}{\texttt{ Event\+System}} and \href{https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/InputModules.html}{\texttt{ Base\+Input\+Module}} subsystem. In other words, the same input setup based on Input\+System\+UIInput\+Module supports input in either UI solution and nothing extra needs to be done.

Internally, UI Toolkit installs an event listener in the form of the {\ttfamily Panel\+Event\+Handler} component which intercepts events that {\ttfamily Input\+System\+UIInput\+Module} sends and translates them into UI Toolkit-\/specific events that are then routed into the visual tree. If you employ {\ttfamily Event\+System.\+Set\+UITookit\+Event\+System\+Override}, this default mechanism is bypassed.

\texorpdfstring{$>$}{>}\mbox{[}!\+NOTE\mbox{]} \texorpdfstring{$>$}{>}XR (tracked-\/type input) is not yet supported in combination with UI Toolkit. This means that you cannot use devices such as VR controllers to operate interfaces created with UI Toolkit.

There are some additional things worth noting\+:


\begin{DoxyItemize}
\item UI Toolkit handles raycasting internally. No separate raycaster component is needed like for u\+GUI. This means that \href{../api/UnityEngine.InputSystem.UI.TrackedDeviceRaycaster.html}{\texttt{ Tracked\+Device\+Raycaster}} does not work together with UI Toolkit.
\item A pointer click and a gamepad submit action are distinct at the event level in UI Toolkit. This means that if you, for example, do 
\begin{DoxyCode}{0}
\DoxyCodeLine{button.RegisterCallback<ClickEvent>(\_\ =>\ ButtonWasClicked());}

\end{DoxyCode}
 the handler is not invoked when the button is "{}clicked"{} with the gamepad (a {\ttfamily Navigation\+Submit\+Event} and not a {\ttfamily Click\+Event}). If, however, you do 
\begin{DoxyCode}{0}
\DoxyCodeLine{button.clicked\ +=\ ()\ =>\ ButtonWasClicked();}

\end{DoxyCode}
 the handle is invoked in both cases. 
\end{DoxyItemize}