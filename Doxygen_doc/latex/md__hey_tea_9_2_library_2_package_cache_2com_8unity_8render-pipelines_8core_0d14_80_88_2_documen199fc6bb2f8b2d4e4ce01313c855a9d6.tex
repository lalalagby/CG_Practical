\chapter{Writing a render pipeline}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6}{}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6}\index{Writing a render pipeline@{Writing a render pipeline}}
\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6_autotoc_md1830}%
\Hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6_autotoc_md1830}%
 This page covers the process of how to use the Render\+Graph API to write a render pipeline. For information about the Render\+Graph API, see \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documentation_0i_2render-graph-system}{render graph system}{0} and \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documend14abe82f76f6781e498841ecaef4692}{render graph fundamentals}{0}.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6_autotoc_md1831}{}\doxysubsection{\texorpdfstring{Initialization and cleanup of Render Graph}{Initialization and cleanup of Render Graph}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6_autotoc_md1831}
To begin, your render pipeline needs to maintain at least one instance of \href{../api/UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph.html}{\texttt{ Render\+Graph}}. This is the main entry point for the API. You can use more than one instance of a render graph, but be aware that \doxylink{namespace_unity}{Unity} does not share resources across {\ttfamily Render\+Graph} instances so for optimal memory usage, only use one instance.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{\textcolor{keyword}{using\ }UnityEngine.Experimental.Rendering.RenderGraphModule;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keyword}{class\ }MyRenderPipeline\ :\ RenderPipeline}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_render_graph}{RenderGraph}}\ m\_RenderGraph;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ InitializeRenderGraph()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ m\_RenderGraph\ =\ \textcolor{keyword}{new}\ \mbox{\hyperlink{class_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_render_graph}{RenderGraph}}(“MyRenderGraph”);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ CleanupRenderGraph()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ m\_RenderGraph.\mbox{\hyperlink{class_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_render_graph_a3cebb3e1096c146fe6ea58c20c64fb3f}{Cleanup}}();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ m\_RenderGraph\ =\ null;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


To initialize a {\ttfamily Render\+Graph} instance, call the constructor with an optional name to identify the render graph. This also registers a render graph-\/specific panel in the SRP Debug window which is useful for debugging the Render\+Graph instance. When you dispose of a render pipeline, call the {\ttfamily Cleanup()} method on the Render\+Graph instance to properly free all the resources the render graph allocated.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6_autotoc_md1832}{}\doxysubsection{\texorpdfstring{Starting a render graph}{Starting a render graph}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6_autotoc_md1832}
Before you add any render passes to the render graph, you first need to initialize the render graph. To do this, call the {\ttfamily Record\+And\+Execute} method. This method will return a disposable struct of type {\ttfamily Render\+Graph\+Execution} that you can use with a scope. When the {\ttfamily Render\+Graph\+Execution} struct exits the scope or its Dispose function is called, the render graph is executed. This pattern ensures that the render graph is always executed correctly even in the case of an exception during the recording of the graph. For details about this method\textquotesingle{}s parameters, see the \href{../api/UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph.html}{\texttt{ API documentation}}


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{var\ renderGraphParams\ =\ \textcolor{keyword}{new}\ RenderGraphExecuteParams()}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ scriptableRenderContext\ =\ renderContext,}
\DoxyCodeLine{\ \ \ \ commandBuffer\ =\ cmd,}
\DoxyCodeLine{\ \ \ \ currentFrameIndex\ =\ frameIndex}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{using}\ (m\_RenderGraph.\mbox{\hyperlink{class_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_render_graph_ab26f01b30edccb4d2ba5883421340273}{RecordAndExecute}}(renderGraphParams))}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Add\ your\ passes\ here}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6_autotoc_md1833}{}\doxysubsection{\texorpdfstring{Creating resources for the render graph}{Creating resources for the render graph}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6_autotoc_md1833}
When you use a render graph, you never directly allocate resources yourself. Instead, the Render\+Graph instance handles the allocation and disposal of its own resources. To declare resources and use them in a render pass, you use render graph specific APIs that return handles to the resource.

There are two main types of resources that a render graph uses\+:


\begin{DoxyItemize}
\item {\bfseries{Internal resources}}\+: These resources are internal to a render graph execution and you cannot access them outside of the Render\+Graph instance. You also cannot pass these resources from one execution of a graph to another. The render graph handles the lifetime of these resources.
\item {\bfseries{Imported resources}}\+: These usually come from outside the render graph execution. Typical examples are the back buffer (provided by the camera) or buffers that you want the graph to use across multiple frames for temporal effects (like using the camera color buffer for temporal anti-\/aliasing). You are responsible for handling the lifetime of these resources.
\end{DoxyItemize}

After you create or import a resource, the render graph system represents it as a resource type-\/specific handle ({\ttfamily Texture\+Handle}, {\ttfamily Compute\+Buffer\+Handle}, or {\ttfamily Renderer\+List\+Handle}). This way, the render graph can use internal and imported resources in the same way in all of its APIs.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{\textcolor{keyword}{public}\ \mbox{\hyperlink{struct_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_texture_handle}{TextureHandle}}\ \mbox{\hyperlink{class_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_render_graph}{RenderGraph}}.\mbox{\hyperlink{class_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_render_graph_a52b03077017a036a3b11864e67f7c7ed}{CreateTexture}}(in\ \mbox{\hyperlink{struct_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_texture_desc}{TextureDesc}}\ desc);}
\DoxyCodeLine{\textcolor{keyword}{public}\ \mbox{\hyperlink{struct_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_compute_buffer_handle}{ComputeBufferHandle}}\ \mbox{\hyperlink{class_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_render_graph}{RenderGraph}}.\mbox{\hyperlink{class_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_render_graph_a05ded8a7fd2f045c9697795cdf469886}{CreateComputeBuffer}}(in\ \mbox{\hyperlink{struct_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_compute_buffer_desc}{ComputeBufferDesc}}\ desc)}
\DoxyCodeLine{\textcolor{keyword}{public}\ \mbox{\hyperlink{struct_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_renderer_list_handle}{RendererListHandle}}\ \mbox{\hyperlink{class_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_render_graph}{RenderGraph}}.\mbox{\hyperlink{class_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_render_graph_a92afcf81d3b60e82bf82bf310f11db63}{CreateRendererList}}(in\ RendererListDesc\ desc);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}\ \mbox{\hyperlink{struct_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_texture_handle}{TextureHandle}}\ \mbox{\hyperlink{class_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_render_graph}{RenderGraph}}.\mbox{\hyperlink{class_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_render_graph_af94ac2654a10825ba5d1bd33fbfae218}{ImportTexture}}(RTHandle\ rt);}
\DoxyCodeLine{\textcolor{keyword}{public}\ \mbox{\hyperlink{struct_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_texture_handle}{TextureHandle}}\ \mbox{\hyperlink{class_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_render_graph}{RenderGraph}}.\mbox{\hyperlink{class_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_render_graph_a02fdfd125621f8faed18201f8dab99bc}{ImportBackbuffer}}(RenderTargetIdentifier\ rt);}
\DoxyCodeLine{\textcolor{keyword}{public}\ \mbox{\hyperlink{struct_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_compute_buffer_handle}{ComputeBufferHandle}}\ \mbox{\hyperlink{class_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_render_graph}{RenderGraph}}.\mbox{\hyperlink{class_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_render_graph_ae635e9178f9c88184d2eeca6aa243a6a}{ImportComputeBuffer}}(ComputeBuffer\ computeBuffer);}

\end{DoxyCode}


The main ways to create resources are described above, but there are variations of these functions. For the complete list, see the \href{../api/UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph.html}{\texttt{ API documentation}}. Note that the specific function to use to import the camera back buffer is {\ttfamily Render\+Target\+Identifier}.

To create resources, each API requires a descriptor structure as a parameter. The properties in these structures are similar to the properties in the resources they represent (respectively \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documentation_0i_2rthandle-system}{RTHandle}{0}, \href{https://docs.unity3d.com/ScriptReference/ComputeBuffer.html}{\texttt{ Compute\+Buffer}}, and \href{../api/UnityEngine.Experimental.Rendering.RendererList.html}{\texttt{ Renderer\+Lists}}). However, some properties are specific to render graph textures.

Here are the most important ones\+:


\begin{DoxyItemize}
\item {\bfseries{clear\+Buffer}}\+: This property tells the graph whether to clear the buffer when the graph creates it. This is how you should clear textures when using the render graph. This is important because a render graph pools resources, which means any pass that creates a texture might get an already existing one with undefined content.
\item {\bfseries{clear\+Color}}\+: This property stores the color to clear the buffer to, if applicable.
\end{DoxyItemize}

There are also two notions specific to textures that a render graph exposes through the {\ttfamily Texture\+Desc} constructors\+:


\begin{DoxyItemize}
\item {\bfseries{xr\+Ready}}\+: This boolean indicates to the graph whether this texture is for XR rendering. If true, the render graph creates the texture as an array for rendering into each XR eye.
\item {\bfseries{dynamic\+Resolution}}\+: This boolean indicates to the graph whether it needs to dynamically resize this texture when the application uses dynamic resolution. If false, the texture does not scale automatically.
\end{DoxyItemize}

You can create resources outside render passes, inside the setup code for a render pass, but not in the rendering code.

Creating a resource outside of all render passes can be useful for cases where the first pass uses a given resource that depends on logic in the code that might change regularly. In this case, you must create the resource before any of those passes. A good example is using the color buffer for either a deferred lighting pass or a forward lighting pass. Both of these passes write to the color buffer, but \doxylink{namespace_unity}{Unity} only executes one of them depending on the current rendering path chosen for the camera. In this case, you would create the color buffer outside both passes and pass it to the correct one as a parameter.

Creating a resource inside a render pass is usually for resources the render pass produces itself. For example, a blur pass requires an already existing input texture, but creates the output itself and returns it at the end of the render pass.

Note that creating a resource like that does not allocate GPU memory every frame. Instead, the render graph system reuses pooled memory. In the context of the render graph, think of resource creation more in terms of data flow in the context of a render pass than actual allocation. If a render pass creates a whole new output then it “creates” a new texture in the render graph.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6_autotoc_md1834}{}\doxysubsection{\texorpdfstring{Writing a render pass}{Writing a render pass}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6_autotoc_md1834}
Before \doxylink{namespace_unity}{Unity} can execute the render graph, you must declare all the render passes. You write a render pass in two parts\+: setup and rendering.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6_autotoc_md1835}{}\doxysubsubsection{\texorpdfstring{Setup}{Setup}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6_autotoc_md1835}
During setup, you declare the render pass and all the data it needs to execute. The render graph represents data by a class specific to the render pass that contains all the relevant properties. These can be regular C\# constructs (struct, Po\+Ds, etc) and render graph resource handles. This data structure is accessible during the actual rendering code.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{\textcolor{keyword}{class\ }MyRenderPassData}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ \textcolor{keywordtype}{float}\ parameter;}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ \mbox{\hyperlink{struct_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_texture_handle}{TextureHandle}}\ inputTexture;}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ \mbox{\hyperlink{struct_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_texture_handle}{TextureHandle}}\ outputTexture;}
\DoxyCodeLine{\}}

\end{DoxyCode}


After you define the pass data, you can then declare the render pass itself\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{\textcolor{keyword}{using}\ (var\ builder\ =\ renderGraph.AddRenderPass<MyRenderPassData>(\textcolor{stringliteral}{"{}My\ Render\ Pass"{}},\ out\ var\ passData))}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ passData.parameter\ =\ 2.5f;}
\DoxyCodeLine{\ \ \ \ passData.inputTexture\ =\ builder.ReadTexture(inputTexture);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_texture_handle}{TextureHandle}}\ output\ =\ renderGraph.CreateTexture(\textcolor{keyword}{new}\ \mbox{\hyperlink{struct_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_texture_desc}{TextureDesc}}(Vector2.one,\ \textcolor{keyword}{true},\ \textcolor{keyword}{true})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ colorFormat\ =\ GraphicsFormat.R8G8B8A8\_UNorm,\ clearBuffer\ =\ \textcolor{keyword}{true},\ clearColor\ =\ Color.black,\ name\ =\ \textcolor{stringliteral}{"{}Output"{}}\ \});}
\DoxyCodeLine{\ \ \ \ passData.outputTexture\ =\ builder.WriteTexture(output);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ builder.SetRenderFunc(myFunc);\ \textcolor{comment}{//\ details\ below.}}
\DoxyCodeLine{\}}

\end{DoxyCode}


You define the render pass in the {\ttfamily using} scope around the {\ttfamily Add\+Render\+Pass} function. At the end of the scope, the render graph adds the render pass to the internal structures of the render graph for later processing.

The {\ttfamily builder} variable is an instance of {\ttfamily Render\+Graph\+Builder}. This is the entry point to build the information relating to the render pass. There are several important parts to this\+:


\begin{DoxyItemize}
\item {\bfseries{Declaring resource usage}}\+: This is one of the most important aspects of the Render\+Graph API. Here you explicitly declare whether the render pass needs read and/or write access to the resources. This allows the render graph to have an overall view of the whole rendering frame and thus determine the best use of GPU memory and synchronization points between various render passes.
\item {\bfseries{Declaring the rendering function}}\+: This is the function in which you call graphics commands. It receives the pass data you define for the render pass as a parameter as well as the render graph context. You set the rendering function for a render pass via {\ttfamily Set\+Render\+Func} and the function runs after the graph compiles.
\item {\bfseries{Creating transient resources}}\+: Transient, or internal, resources are resources you create for the duration of this render pass only. You create them in the builder rather than the render graph itself to reflect their lifetime. Creating transient resources uses the same parameters as the equivalent function in the Render\+Graph APIs. This is particularly useful when a pass uses temporary buffers that should not be accessible outside of the pass. Outside the pass where you declare a transient resource, the handle to the resource becomes invalid and \doxylink{namespace_unity}{Unity} throws errors if you try to use it.
\end{DoxyItemize}

The {\ttfamily pass\+Data} variable is an instance of the type you provide when you declare the pass. This is where you set the data that the rendering code can access. Note that the render graph does not use the contents of {\ttfamily pass\+Data} right away, but later in the frame, after it registers all the passes and the render graph compiles and executes. This means that any reference the {\ttfamily pass\+Data} stores must be constant across the whole frame. Otherwise, if you change the content before the render pass executes, it does not contain the correct content during the render pass. For this reason, it is best practice to only store value types in the {\ttfamily pass\+Data} unless you are certain that a reference stays constant until the pass finishes execution.

For an overview of the {\ttfamily Render\+Graph\+Builder} APIs, see the below table. For more details, see the API documentation\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Function   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Purpose    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Function   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Purpose    }\\\cline{1-2}
\endhead
Texture\+Handle Read\+Texture(in Texture\+Handle input)   &Declares that the render pass reads from the {\ttfamily input} texture you pass into the function.    \\\cline{1-2}
Texture\+Handle Write\+Texture(in Texture\+Handle input)   &Declares that the render pass writes to the {\ttfamily input} texture you pass into the function.    \\\cline{1-2}
Texture\+Handle Use\+Color\+Buffer(in Texture\+Handle input, int index)   &Same as {\ttfamily Write\+Texture} but also automatically binds the texture as a render texture at the provided binding index at the beginning of the pass.    \\\cline{1-2}
Texture\+Handle Use\+Depth\+Buffer(in Texture\+Handle input, Depth\+Access flags)   &Same as {\ttfamily Write\+Texture} but also automatically binds the texture as a depth texture with the access flags you pass into the function.    \\\cline{1-2}
Texture\+Handle Create\+Transient\+Texture(in Texture\+Desc desc)   &Create a transient texture. This texture exists for the duration of the pass.    \\\cline{1-2}
Renderer\+List\+Handle Use\+Renderer\+List(in Renderer\+List\+Handle input)   &Declares that this render pass uses the Renderer List you pass in. The render pass uses the {\ttfamily Renderer\+List.\+Draw} command to render the list.    \\\cline{1-2}
Compute\+Buffer\+Handle Read\+Compute\+Buffer(in Compute\+Buffer\+Handle input)   &Declares that the render pass reads from the {\ttfamily input} Compute\+Buffer you pass into the function.    \\\cline{1-2}
Compute\+Buffer\+Handle Write\+Compute\+Buffer(in Compute\+Buffer\+Handle input)   &Declares that the render pass writes to the {\ttfamily input} Compute Buffer you pass into the function.    \\\cline{1-2}
Compute\+Buffer\+Handle Create\+Transient\+Compute\+Buffer(in Compute\+Buffer\+Desc desc)   &Create a transient Compute Buffer. This texture exists for the duration of the Compute Buffer.    \\\cline{1-2}
void Set\+Render\+Func$<$\+Pass\+Data$>$(\+Render\+Func$<$\+Pass\+Data$>$ render\+Func) where Pass\+Data \+: class, new()   &Set the rendering function for the render pass.    \\\cline{1-2}
void Enable\+Async\+Compute(bool value)   &Declares that the render pass runs on the asynchronous compute pipeline.    \\\cline{1-2}
void Allow\+Pass\+Culling(bool value)   &Specifies whether \doxylink{namespace_unity}{Unity} should cull the render pass (default is true). This can be useful when the render pass has side effects and you never want the render graph system to cull.   \\\cline{1-2}
\end{longtabu}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6_autotoc_md1836}{}\doxysubsubsection{\texorpdfstring{Rendering Code}{Rendering Code}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6_autotoc_md1836}
After you complete the setup, you can declare the function to use for rendering via the {\ttfamily Set\+Render\+Func} method on the {\ttfamily Render\+Graph\+Builder}. The function you assign must use the following signature\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{delegate\ \textcolor{keywordtype}{void}\ RenderFunc<PassData>(PassData\ data,\ \mbox{\hyperlink{class_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_render_graph_context}{RenderGraphContext}}\ renderGraphContext)\ where\ PassData\ :\ \textcolor{keyword}{class},\ \textcolor{keyword}{new}();}

\end{DoxyCode}


You can either pass a render function as a {\ttfamily static} function or a lambda. The benefit of using a lambda function is that it can bring better code clarity because the rendering code is next to the setup code.

Note that if you use a lambda, be very careful not to capture any parameters from the main scope of the function as that generates garbage, which \doxylink{namespace_unity}{Unity} later locates and frees during garbage collection. If you use Visual Studio and hover over the arrow \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}=\texorpdfstring{$>$}{>}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}, it tells you if the lambda captures anything from the scope. Avoid accessing members or member functions because using either captures {\ttfamily this}.

The render function takes two parameters\+:


\begin{DoxyItemize}
\item {\ttfamily Pass\+Data data}\+: This data is of the type you pass in when you declare the render pass. This is where you can access the properties initialized during the setup phase and use them for the rendering code.
\item {\ttfamily Render\+Graph\+Context render\+Graph\+Context}. This stores references to the {\ttfamily Scriptable\+Render\+Context} and the {\ttfamily Command\+Buffer} that provide utility functions and allow you to write rendering code.
\end{DoxyItemize}\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6_autotoc_md1837}{}\doxysubsubsubsection{\texorpdfstring{Accessing resources in the render pass}{Accessing resources in the render pass}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6_autotoc_md1837}
Inside the rendering function, you can access all the render graph resource handles stored inside the {\ttfamily pass\+Data}. The conversion to actual resources is automatic so, whenever a function needs an RTHandle, a Compute\+Buffer, or a Renderer\+List, you can pass the handle and the render graph converts the handle to the actual resource implicitly. Note that doing such implicit conversion outside of a rendering function results in an exception. This exception occurs because, outside of rendering, the render graph may have not allocated those resources yet.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6_autotoc_md1838}{}\doxysubsubsubsection{\texorpdfstring{Using the Render\+Graph\+Context}{Using the Render\+Graph\+Context}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6_autotoc_md1838}
The Render\+Graph\+Context provides various functionality you need to write rendering code. The two most important are the {\ttfamily Scriptable\+Render\+Context} and the {\ttfamily Command\+Buffer}, which you use to call all rendering commands.

The Render\+Graph\+Context also contains the {\ttfamily Render\+Graph\+Object\+Pool}. This class helps you to manage temporary objects that you might need for rendering code.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6_autotoc_md1839}{}\doxysubsubsubsection{\texorpdfstring{Get temp functions}{Get temp functions}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6_autotoc_md1839}
Two functions that are particularly useful during render passes are {\ttfamily Get\+Temp\+Array} and {\ttfamily Get\+Temp\+Material\+Property\+Block}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{\mbox{\hyperlink{namespace_unity_engine_1_1_input_system_ad8a6cae0143584257f5a72d1842ea496ab9ece18c950afbfa6b0fdbfa4ff731d3}{T}}[]\ GetTempArray<T>(\textcolor{keywordtype}{int}\ size);}
\DoxyCodeLine{MaterialPropertyBlock\ GetTempMaterialPropertyBlock();}

\end{DoxyCode}


{\ttfamily Get\+Temp\+Array} returns a temporary array of type {\ttfamily T} and size {\ttfamily size}. This can be useful to allocate temporary arrays for passing parameters to materials or creating a {\ttfamily Render\+Target\+Identifier} array to create multiple render target setups without the need to manage the array’s lifetime yourself.

{\ttfamily Get\+Temp\+Material\+Property\+Block} returns a clean material property block that you can use to set up parameters for a Material. This is particularly important because more than one pass might use a material and each pass could use it with different parameters. Because the rendering code execution is deferred via command buffers, copying material property blocks into the command buffer is mandatory to preserve data integrity on execution.

The render graph releases and pools all the resources these two functions return automatically after the pass execution. This means you don’t have to manage them yourself and does not create garbage.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6_autotoc_md1840}{}\doxysubsubsection{\texorpdfstring{Example render pass}{Example render pass}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6_autotoc_md1840}
The following code example contains a render pass with a setup and render function\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{\mbox{\hyperlink{struct_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_texture_handle}{TextureHandle}}\ MyRenderPass(\mbox{\hyperlink{class_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_render_graph}{RenderGraph}}\ renderGraph,\ \mbox{\hyperlink{struct_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_texture_handle}{TextureHandle}}\ inputTexture,\ \textcolor{keywordtype}{float}\ parameter,\ Material\ material)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{using}\ (var\ builder\ =\ renderGraph.AddRenderPass<MyRenderPassData>(\textcolor{stringliteral}{"{}My\ Render\ Pass"{}},\ out\ var\ passData))}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ passData.parameter\ =\ parameter;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ passData.material\ =\ material;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Tells\ the\ graph\ that\ this\ pass\ will\ read\ inputTexture.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ passData.inputTexture\ =\ builder.ReadTexture(inputTexture);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Creates\ the\ output\ texture.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \mbox{\hyperlink{struct_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_texture_handle}{TextureHandle}}\ output\ =\ renderGraph.\mbox{\hyperlink{class_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_render_graph_a52b03077017a036a3b11864e67f7c7ed}{CreateTexture}}(\textcolor{keyword}{new}\ \mbox{\hyperlink{struct_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_texture_desc}{TextureDesc}}(Vector2.one,\ \textcolor{keyword}{true},\ \textcolor{keyword}{true})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ colorFormat\ =\ GraphicsFormat.R8G8B8A8\_UNorm,\ clearBuffer\ =\ \textcolor{keyword}{true},\ clearColor\ =\ Color.black,\ name\ =\ \textcolor{stringliteral}{"{}Output"{}}\ \});}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Tells\ the\ graph\ that\ this\ pass\ will\ write\ this\ texture\ and\ needs\ to\ be\ set\ as\ render\ target\ 0.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ passData.outputTexture\ =\ builder.UseColorBuffer(output,\ 0);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ builder.SetRenderFunc(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ (MyRenderPassData\ data,\ \mbox{\hyperlink{class_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_render_graph_context}{RenderGraphContext}}\ ctx)\ =>}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Render\ Target\ is\ already\ set\ via\ the\ use\ of\ UseColorBuffer\ above.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ If\ builder.WriteTexture\ was\ used,\ you'd\ need\ to\ do\ something\ like\ that:}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ CoreUtils.SetRenderTarget(ctx.cmd,\ data.output);}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Setup\ material\ for\ rendering}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ var\ materialPropertyBlock\ =\ ctx.\mbox{\hyperlink{class_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_render_graph_context_af765352098bf2e89a6af2dac5071b4aa}{renderGraphPool}}.\mbox{\hyperlink{class_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_render_graph_object_pool_abc37f856e524a086dbbc1fefbf40131e}{GetTempMaterialPropertyBlock}}();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ materialPropertyBlock.SetTexture(\textcolor{stringliteral}{"{}\_MainTexture"{}},\ data.input);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ materialPropertyBlock.SetFloat(\textcolor{stringliteral}{"{}\_FloatParam"{}},\ data.parameter);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ CoreUtils.DrawFullScreen(ctx.\mbox{\hyperlink{class_unity_engine_1_1_experimental_1_1_rendering_1_1_render_graph_module_1_1_render_graph_context_ae9dca4dbfff9972bb274f0d497c90493}{cmd}},\ data.material,\ materialPropertyBlock);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ output;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6_autotoc_md1841}{}\doxysubsection{\texorpdfstring{Ending the frame}{Ending the frame}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8render-pipelines_8core_0d14_80_88_2_documen199fc6bb2f8b2d4e4ce01313c855a9d6_autotoc_md1841}
Over the course of your application, the render graph needs to allocate various resources. It might use these resources for a time but then might not need them. For the graph to free up those resources, call the {\ttfamily End\+Frame()} method once a frame. This deallocates any resources that the render graph has not used since the last frame. This also executes all internal processing the render graph requires at the end of the frame.

Note that you should only call this once per frame and after all the rendering is complete (for example, after the last camera renders). This is because different cameras might have different rendering paths and thus need different resources. Calling the purge after each camera could result in the render graph releasing resources too early even though they might be necessary for the next camera. 