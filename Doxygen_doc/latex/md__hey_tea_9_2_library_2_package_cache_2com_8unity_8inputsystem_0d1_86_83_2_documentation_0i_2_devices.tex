\chapter{Devices}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices}{}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices}\index{Devices@{Devices}}
\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1324}%
\Hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1324}%

\begin{DoxyItemize}
\item Devices
\begin{DoxyItemize}
\item Device descriptions
\begin{DoxyItemize}
\item Capabilities
\item Matching
\begin{DoxyItemize}
\item Hijacking the matching process
\end{DoxyItemize}
\item Device lifecycle
\begin{DoxyItemize}
\item Device creation
\item Device removal
\item Device resets
\item Device syncs
\item Device enabling and disabling
\item Background and focus change behavior
\item Domain reloads in the Editor
\end{DoxyItemize}
\end{DoxyItemize}
\item Native Devices
\begin{DoxyItemize}
\item Disconnected Devices
\end{DoxyItemize}
\item Device IDs
\item Device usages
\item Device commands
\begin{DoxyItemize}
\item Sending commands to Devices
\item Adding custom device Commands
\end{DoxyItemize}
\item Device state
\begin{DoxyItemize}
\item State changes
\begin{DoxyItemize}
\item Monitoring state changes
\item Synthesizing state
\end{DoxyItemize}
\end{DoxyItemize}
\item Working with Devices
\begin{DoxyItemize}
\item Monitoring Devices
\item Adding and removing Devices
\item Creating custom Devices
\begin{DoxyItemize}
\item Step 1\+: The state struct
\item Step 2\+: The Device class
\item Step 3\+: The Update method
\item Step 4\+: Device registration and creation
\item Step 5\+: \`{}current\`{} and \`{}all\`{} (optional)
\item Step 6\+: Device Commands (Optional)
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}

Physically, Input Devices represent devices attached to the computer, which a user can use to control the app. Logically, Input Devices are the top-\/level container for \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_controls}{Controls}{0}. The \href{../api/UnityEngine.InputSystem.InputDevice.html}{\texttt{ {\ttfamily Input\+Device}}} class is itself a specialization of \href{../api/UnityEngine.InputSystem.InputControl.html}{\texttt{ {\ttfamily Input\+Control}}}. See \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_supported_devices}{supported Devices}{0} to see what kind of Devices the Input \doxylink{namespace_system}{System} currently supports.

To query the set of all currently present Devices, you can use \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_devices}{\texttt{ {\ttfamily Input\+System.\+devices}}}.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1325}{}\doxysection{\texorpdfstring{Device descriptions}{Device descriptions}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1325}
An \href{../api/UnityEngine.InputSystem.Layouts.InputDeviceDescription.html}{\texttt{ {\ttfamily Input\+Device\+Description}}} describes a Device. The Input \doxylink{namespace_system}{System} uses this primarily during the Device discovery process. When a new Device is reported (by the runtime or by the user), the report contains a Device description. Based on the description, the system then attempts to find a Device \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts}{layout}{0} that matches the description. This process is based on Device matchers.

After a Device has been created, you can retrieve the description it was created from through the \href{../api/UnityEngine.InputSystem.InputDevice.html\#UnityEngine_InputSystem_InputDevice_description}{\texttt{ {\ttfamily Input\+Device.\+description}}} property.

Every description has a set of standard fields\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Field   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Field   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-2}
\endhead
\href{../api/UnityEngine.InputSystem.Layouts.InputDeviceDescription.html\#UnityEngine_InputSystem_Layouts_InputDeviceDescription_interfaceName}{\texttt{ {\ttfamily interface\+Name}}}   &Identifier for the interface/\+API that is making the Device available. In many cases, this corresponds to the name of the platform, but there are several more specific interfaces that are commonly used\+: \href{https://www.usb.org/hid}{\texttt{ HID}}, \href{https://docs.microsoft.com/en-us/windows/desktop/inputdev/raw-input}{\texttt{ Raw\+Input}}, \href{https://docs.microsoft.com/en-us/windows/desktop/xinput/xinput-game-controller-apis-portal}{\texttt{ XInput}}.~\newline
This field is required.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.Layouts.InputDeviceDescription.html\#UnityEngine_InputSystem_Layouts_InputDeviceDescription_deviceClass}{\texttt{ {\ttfamily device\+Class}}}   &A broad categorization of the Device. For example, "{}\+Gamepad"{} or "{}\+Keyboard"{}.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.Layouts.InputDeviceDescription.html\#UnityEngine_InputSystem_Layouts_InputDeviceDescription_product}{\texttt{ {\ttfamily product}}}   &Name of the product as reported by the Device/driver itself.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.Layouts.InputDeviceDescription.html\#UnityEngine_InputSystem_Layouts_InputDeviceDescription_manufacturer}{\texttt{ {\ttfamily manufacturer}}}   &Name of the manufacturer as reported by the Device/driver itself.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.Layouts.InputDeviceDescription.html\#UnityEngine_InputSystem_Layouts_InputDeviceDescription_version}{\texttt{ {\ttfamily version}}}   &If available, provides the version of the driver or hardware for the Device.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.Layouts.InputDeviceDescription.html\#UnityEngine_InputSystem_Layouts_InputDeviceDescription_serial}{\texttt{ {\ttfamily serial}}}   &If available, provides the serial number for the Device.    \\\cline{1-2}
\href{../api/UnityEngine.InputSystem.Layouts.InputDeviceDescription.html\#UnityEngine_InputSystem_Layouts_InputDeviceDescription_capabilities}{\texttt{ {\ttfamily capabilities}}}   &A string in JSON format that describes Device/interface-\/specific capabilities. See the section on capabilities.   \\\cline{1-2}
\end{longtabu}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1326}{}\doxysubsection{\texorpdfstring{Capabilities}{Capabilities}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1326}
Aside from a number of standardized fields, such as {\ttfamily product} and {\ttfamily manufacturer}, a Device description can contain a \href{../api/UnityEngine.InputSystem.Layouts.InputDeviceDescription.html\#UnityEngine_InputSystem_Layouts_InputDeviceDescription_capabilities}{\texttt{ {\ttfamily capabilities}}} string in JSON format. This string describes characteristics which help the Input \doxylink{namespace_system}{System} to interpret the data from a Device, and map it to Control representations. Not all Device interfaces report Device capabilities. Examples of interface-\/specific Device capabilities are \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_h_i_d}{HID descriptors}{0}. Web\+GL, Android, and Linux use similar mechanisms to report available Controls on connected gamepads.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1327}{}\doxysubsection{\texorpdfstring{Matching}{Matching}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1327}
\href{../api/UnityEngine.InputSystem.Layouts.InputDeviceMatcher.html}{\texttt{ {\ttfamily Input\+Device\+Matcher}}} instances handle matching an \href{../api/UnityEngine.InputSystem.Layouts.InputDeviceDescription.html}{\texttt{ {\ttfamily Input\+Device\+Description}}} to a registered layout. Each matcher loosely functions as a kind of regular expression. Each field in the description can be independently matched with either a plain string or regular expression. Matching is not case-\/sensitive. For a matcher to apply, all of its individual expressions have to match.

To matchers to any layout, call \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_RegisterLayoutMatcher_System_String_UnityEngine_InputSystem_Layouts_InputDeviceMatcher_}{\texttt{ {\ttfamily Input\+System.\+Register\+Layout\+Matcher}}}. You can also supply them when you register a layout.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Register\ a\ new\ layout\ and\ supply\ a\ matcher\ for\ it.}}
\DoxyCodeLine{InputSystem.RegisterLayoutMatcher<MyDevice>(}
\DoxyCodeLine{\ \ \ \ matches:\ \textcolor{keyword}{new}\ InputDeviceMatcher()}
\DoxyCodeLine{\ \ \ \ \ \ \ \ .WithInterface(\textcolor{stringliteral}{"{}HID"{}})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ .WithProduct(\textcolor{stringliteral}{"{}MyDevice.*"{}})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ .WithManufacturer(\textcolor{stringliteral}{"{}MyBrand"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Register\ an\ alternate\ matcher\ for\ an\ already\ registered\ layout.}}
\DoxyCodeLine{InputSystem.RegisterLayoutMatcher<MyDevice>(}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{new}\ InputDeviceMatcher()}
\DoxyCodeLine{\ \ \ \ \ \ \ \ .WithInterface(\textcolor{stringliteral}{"{}HID"{}})}

\end{DoxyCode}


If multiple matchers are matching the same \href{../api/UnityEngine.InputSystem.Layouts.InputDeviceDescription.html}{\texttt{ {\ttfamily Input\+Device\+Description}}}, the Input \doxylink{namespace_system}{System} chooses the matcher that has the larger number of properties to match against.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1328}{}\doxysubsubsection{\texorpdfstring{Hijacking the matching process}{Hijacking the matching process}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1328}
You can overrule the internal matching process from outside to select a different layout for a Device than the system would normally choose. This also makes it possible to quickly build new layouts. To do this, add a custom handler to the \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_onFindLayoutForDevice}{\texttt{ {\ttfamily Input\+System.\+on\+Find\+Control\+Layout\+For\+Device}}} event. If your handler returns a non-\/null layout string, then the Input \doxylink{namespace_system}{System} uses this layout.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1329}{}\doxysubsection{\texorpdfstring{Device lifecycle}{Device lifecycle}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1329}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1330}{}\doxysubsubsection{\texorpdfstring{Device creation}{Device creation}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1330}
Once the system has chosen a \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts}{layout}{0} for a device, it instantiates an \href{../api/UnityEngine.InputSystem.InputDevice.html}{\texttt{ {\ttfamily Input\+Device}}} and populates it with \href{../api/UnityEngine.InputSystem.InputControl.html}{\texttt{ {\ttfamily Input\+Controls}}} as the layout dictates. This process is internal and happens automatically.

\texorpdfstring{$>$}{>}{\bfseries{Note}}\+: You can\textquotesingle{}t create valid \href{../api/UnityEngine.InputSystem.InputDevice.html}{\texttt{ {\ttfamily Input\+Devices}}} and \href{../api/UnityEngine.InputSystem.InputControl.html}{\texttt{ {\ttfamily Input\+Controls}}} by manually instantiating them with {\ttfamily new}. To guide the creation process, you must use \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts}{layouts}{0}.

After the Input \doxylink{namespace_system}{System} assembles the \href{../api/UnityEngine.InputSystem.InputDevice.html}{\texttt{ {\ttfamily Input\+Device}}}, it calls \href{../api/UnityEngine.InputSystem.InputControl.html\#UnityEngine_InputSystem_InputControl_FinishSetup_}{\texttt{ {\ttfamily Finish\+Setup}}} on each control of the device and on the device itself. Use this to finalize the setup of the Controls.

After an \href{../api/UnityEngine.InputSystem.InputDevice.html}{\texttt{ {\ttfamily Input\+Device}}} is fully assembled, the Input \doxylink{namespace_system}{System} adds it to the system. As part of this process, the Input \doxylink{namespace_system}{System} calls \href{../api/UnityEngine.InputSystem.InputDevice.html\#UnityEngine_InputSystem_InputDevice_MakeCurrent_}{\texttt{ {\ttfamily Make\+Current}}} on the Device, and signals \href{../api/UnityEngine.InputSystem.InputDeviceChange.html\#UnityEngine_InputSystem_InputDeviceChange_Added}{\texttt{ {\ttfamily Input\+Device\+Change.\+Added}}} on \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_onDeviceChange}{\texttt{ {\ttfamily Input\+System.\+on\+Device\+Change}}}. The Input \doxylink{namespace_system}{System} also calls \href{../api/UnityEngine.InputSystem.InputDevice.html\#UnityEngine_InputSystem_InputDevice_OnAdded_}{\texttt{ {\ttfamily Input\+Device.\+On\+Added}}}.

Once added, the \href{../api/UnityEngine.InputSystem.InputDevice.html\#UnityEngine_InputSystem_InputDevice_added}{\texttt{ {\ttfamily Input\+Device.\+added}}} flag is set to true.

To add devices manually, you can call one of the {\ttfamily Input\+System.\+Add\+Device} methods such as \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_AddDevice_System_String_System_String_System_String_}{\texttt{ {\ttfamily Input\+System.\+Add\+Device(layout)}}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Add\ a\ gamepad.\ This\ bypasses\ the\ matching\ process\ and\ creates\ a\ device\ directly}}
\DoxyCodeLine{\textcolor{comment}{//\ with\ the\ Gamepad\ layout.}}
\DoxyCodeLine{InputSystem.AddDevice<Gamepad>();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Add\ a\ device\ such\ that\ the\ matching\ process\ is\ employed:}}
\DoxyCodeLine{InputSystem.AddDevice(\textcolor{keyword}{new}\ InputDeviceDescription}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ interfaceName\ =\ \textcolor{stringliteral}{"{}XInput"{}},}
\DoxyCodeLine{\ \ \ \ product\ =\ \textcolor{stringliteral}{"{}Xbox\ Controller"{}},}
\DoxyCodeLine{\});}

\end{DoxyCode}


When a device is added, the Input \doxylink{namespace_system}{System} automatically issues a \href{../api/UnityEngine.InputSystem.LowLevel.RequestSyncCommand.html}{\texttt{ sync request}} on the device. This instructs the device to send an event representing its current state. Whether this request succeeds depends on the whether the given device supports the sync command.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1331}{}\doxysubsubsection{\texorpdfstring{Device removal}{Device removal}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1331}
When a Device is disconnected, it is removed from the system. A notification appears for \href{../api/UnityEngine.InputSystem.InputDeviceChange.html}{\texttt{ {\ttfamily Input\+Device\+Change.\+Removed}}} (sent via \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_onDeviceChange}{\texttt{ {\ttfamily Input\+System.\+on\+Device\+Change}}}) and the Devices are removed from the \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_onDeviceChange}{\texttt{ {\ttfamily devices}}} list. The system also calls \href{../api/UnityEngine.InputSystem.InputDevice.html\#UnityEngine_InputSystem_InputDevice_OnRemoved_}{\texttt{ {\ttfamily Input\+Device.\+On\+Removed}}}.

The \href{../api/UnityEngine.InputSystem.InputDevice.html\#UnityEngine_InputSystem_InputDevice_added}{\texttt{ {\ttfamily Input\+Device.\+added}}} flag is reset to false in the process.

Note that Devices are not destroyed when removed. Device instances remain valid and you can still access them in code. However, trying to read values from the controls of these Devices leads to exceptions.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1332}{}\doxysubsubsection{\texorpdfstring{Device resets}{Device resets}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1332}
Resetting a Device resets its Controls to their default state. You can do this manually using \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_ResetDevice_UnityEngine_InputSystem_InputDevice_System_Boolean_}{\texttt{ {\ttfamily Input\+System.\+Reset\+Device}}}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{InputSystem.ResetDevice(Gamepad.current);}

\end{DoxyCode}


There are two types of resets as determined by the second parameter to \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_ResetDevice_UnityEngine_InputSystem_InputDevice_System_Boolean_}{\texttt{ {\ttfamily Input\+System.\+Reset\+Device}}}\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-2}
\endhead
"{}\+Soft"{} Resets   &This is the default. With this type, only controls that are {\itshape not} marked as \href{Layouts.md\#control-items}{\texttt{ {\ttfamily dont\+Reset}}} are reset to their default value. This excludes controls such as \href{../api/UnityEngine.InputSystem.Pointer.html\#UnityEngine_InputSystem_Pointer_position}{\texttt{ {\ttfamily Pointer.\+position}}} from resets and thus prevents mouse positions resetting to {\ttfamily (0,0)}.    \\\cline{1-2}
"{}\+Hard"{} Resets   &In this type, {\itshape all} controls are reset to their default value regardless of whether they have \href{Layouts.md\#control-items}{\texttt{ {\ttfamily dont\+Reset}}} set or not.   \\\cline{1-2}
\end{longtabu}


Resetting Controls this way is visible on \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_actions}{Actions}{0}. If you reset a Device that is currently driving one or more Action, the Actions are cancelled. This cancellation is different from sending an event with default state. Whereas the latter may inadvertently \href{../api/UnityEngine.InputSystem.InputAction.html\#UnityEngine_InputSystem_InputAction_performed}{\texttt{ perform}} Actions (e.\+g. a button that was pressed would not appear to have been released), a reset will force clean cancellation.

Resets may be triggered automatically by the Input \doxylink{namespace_system}{System} depending on application focus.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1333}{}\doxysubsubsection{\texorpdfstring{Device syncs}{Device syncs}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1333}
A Device may be requested to send an event with its current state through \href{../api/UnityEngine.InputSystem.LowLevel.RequestSyncCommand.html}{\texttt{ {\ttfamily Request\+Sync\+Command}}}. It depends on the platform and type of Device whether this is supported or not.

A synchronization request can be explicitly sent using \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_TrySyncDevice_UnityEngine_InputSystem_InputDevice_}{\texttt{ {\ttfamily Input\+System.\+Try\+Sync\+Device}}}. If the device supports sync requests, the method returns true and an \href{../api/UnityEngine.InputSystem.LowLevel.InputEvent.html}{\texttt{ {\ttfamily Input\+Event}}} will have been queued on the device for processing in the next \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_Update_}{\texttt{ update}}.

Synchronization requests are also automatically sent by the Input \doxylink{namespace_system}{System} in certain situations. See Background and focus change behavior for more details.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1334}{}\doxysubsubsection{\texorpdfstring{Device enabling and disabling}{Device enabling and disabling}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1334}
When a Device is added, the Input \doxylink{namespace_system}{System} sends it an initial \href{../api/UnityEngine.InputSystem.LowLevel.QueryEnabledStateCommand.html}{\texttt{ {\ttfamily Query\+Enabled\+State\+Command}}} to find out whether the device is currently enabled or not. The result of this is reflected in the \href{../api/UnityEngine.InputSystem.InputDevice.html\#UnityEngine_InputSystem_InputDevice_enabled}{\texttt{ {\ttfamily Input\+Device.\+enabled}}} property.

When disabled, no events other than removal (\href{../api/UnityEngine.InputSystem.LowLevel.DeviceRemoveEvent.html}{\texttt{ {\ttfamily Device\+Remove\+Event}}}) and configuration change (\href{../api/UnityEngine.InputSystem.LowLevel.DeviceConfigurationEvent.html}{\texttt{ {\ttfamily Device\+Configuration\+Event}}}) events are processed for a Device, even if they are sent.

A Device can be manually disabled and re-\/enabled via \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_DisableDevice_}{\texttt{ {\ttfamily Input\+System.\+Disable\+Device}}} and \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_EnableDevice_}{\texttt{ {\ttfamily Input\+System.\+Enable\+Device}}} respectively.

Note that \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_sensors}{sensors}{0} start in a disabled state by default, and you need to enable them in order for them to generate events.

The Input \doxylink{namespace_system}{System} may automatically disable and re-\/enable Devices in certain situations, as detailed in the next section.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1335}{}\doxysubsubsection{\texorpdfstring{Background and focus change behavior}{Background and focus change behavior}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1335}
In general, input is tied to \href{https://docs.unity3d.com/ScriptReference/Application-isFocused.html}{\texttt{ application focus}}. This means that Devices do not receive input while the application is not in the foreground and thus no \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_actions}{Actions}{0} will receive input either. When the application comes back into focus, all devices will receive a sync request to have them send their current state (which may have changed while the application was in the background) to the application. Devices that do not support sync requests will see a soft reset that resets all Controls not marked as \href{Layouts.md\#control-items}{\texttt{ {\ttfamily dont\+Reset}}} to their default state.

On platforms such as i\+OS and Android, that do not support running \doxylink{namespace_unity}{Unity} applications in the background, this is the only supported behavior.

If the application is configured to run while in the background (that is, not having focus), input behavior can be selected from several options. This is supported in two scenarios\+:


\begin{DoxyItemize}
\item In \doxylink{namespace_unity}{Unity}\textquotesingle{}s \href{https://docs.unity3d.com/Manual/class-PlayerSettings.html}{\texttt{ Player Settings}} you can explicity enable {\ttfamily Run In Background} for specific players that support it (such as Windows or Mac standalone players). Note that in these players this setting is always enabled automatically in {\itshape development} players.
\item In the editor, application focus is tied to focus on the Game View. If no Game View is focused, the application is considered to be running in the background. However, while in play mode, the editor will {\itshape always} keep running the player loop regardless of focus on the Game View window. This means that in the editor, {\ttfamily Run In Background} is considered to always be enabled.
\end{DoxyItemize}

If the application is configured this way to keep running while in the background, the player loop and thus the Input \doxylink{namespace_system}{System}, too, will keep running even when the application does not have focus. What happens with respect to input then depends on two factors\+:


\begin{DoxyEnumerate}
\item On the ability of individual devices to receive input while the application is not running in the foreground. This is only supported by a small subset of devices and platforms. VR devices (\href{../api/UnityEngine.InputSystem.TrackedDevice.html}{\texttt{ {\ttfamily Tracked\+Device}}}) such as HMDs and VR controllers generally support this.~\newline
~\newline
To find out whether a specific device supports this, you can query the \href{../api/UnityEngine.InputSystem.InputDevice.html\#UnityEngine_InputSystem_InputDevice_canRunInBackground}{\texttt{ {\ttfamily Input\+Device.\+can\+Run\+In\+Background}}} property. This property can also be forced to true or false via a Device\textquotesingle{}s \href{Layouts.md\#control-items}{\texttt{ layout}}.
\item On two settings you can find in the project-\/wide \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_settings}{Input Settings}{0}. Specifically, \href{../api/UnityEngine.InputSystem.InputSettings.html\#UnityEngine_InputSystem_InputSettings_backgroundBehavior}{\texttt{ {\ttfamily Input\+Settings.\+background\+Behavior}}}\+:~\newline
~\newline
and \href{../api/UnityEngine.InputSystem.InputSettings.html\#UnityEngine_InputSystem_InputSettings_editorInputBehaviorInPlayMode}{\texttt{ {\ttfamily Input\+Settings.\+editor\+Input\+Behavior\+In\+Play\+Mode}}}\+:~\newline
~\newline
The table below shows a detailed breakdown of how input behaviors vary based on these two settings and in relation to the {\ttfamily Run In Background} player setting in \doxylink{namespace_unity}{Unity}.
\end{DoxyEnumerate}

\texorpdfstring{$>$}{>}{\bfseries{Note}}\+: \href{../api/UnityEngine.InputSystem.InputDevice.html\#UnityEngine_InputSystem_InputDevice_canRunInBackground}{\texttt{ {\ttfamily Input\+Device.\+can\+Run\+In\+Background}}} is overridden by the editor in certain situations (see table below). In general, the value of the property does not have to be the same between the editor and the player and depends on the specific platform and device.

The following table shows the full matrix of behaviors according to the \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_settings}{Input Settings}{0} and whether the game is running in the editor or in the player.

\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1336}{}\doxysubsubsection{\texorpdfstring{Domain reloads in the Editor}{Domain reloads in the Editor}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1336}
The Editor reloads the C\# application domain whenever it reloads and recompiles scripts, or when the Editor goes into Play mode. This requires the Input \doxylink{namespace_system}{System} to reinitialize itself after each domain reload. During this process, the Input \doxylink{namespace_system}{System} attempts to recreate devices that were instantiated before the domain reload. However, the state of each Device doesn\textquotesingle{}t carry across, which means that Devices reset to their default state on domain reloads.

Note that layout registrations do not persist across domain reloads. Instead, the Input \doxylink{namespace_system}{System} relies on all registrations to become available as part of the initialization process (for example, by using {\ttfamily \mbox{[}Initialize\+On\+Load\mbox{]}} to run registration as part of the domain startup code in the Editor). This allows you to change registrations and layouts in script, and the change to immediately take effect after a domain reload.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1337}{}\doxysection{\texorpdfstring{Native Devices}{Native Devices}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1337}
Devices that the \href{Architecture.md\#native-backend}{\texttt{ native backend}} reports are considered native (as opposed to Devices created from script code). To identify these Devices, you can check the \href{../api/UnityEngine.InputSystem.InputDevice.html\#UnityEngine_InputSystem_InputDevice_native}{\texttt{ {\ttfamily Input\+Device.\+native}}} property.

The Input \doxylink{namespace_system}{System} remembers native Devices. For example, if the system has no matching layout when the Device is first reported, but a layout which matches the device is registered later, the system uses this layout to recreate the Device.

You can force the Input \doxylink{namespace_system}{System} to use your own \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts}{layout}{0} when the native backend discovers a specific Device, by describing the Device in the layout, like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ "{}name"{}\ :\ "{}MyGamepad"{},}
\DoxyCodeLine{\ \ \ "{}extend"{}\ :\ "{}Gamepad"{},}
\DoxyCodeLine{\ \ \ "{}device"{}\ :\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ //\ All\ strings\ in\ here\ are\ regexs\ and\ case-\/insensitive.}
\DoxyCodeLine{\ \ \ \ \ \ \ "{}product"{}\ :\ "{}MyController"{},}
\DoxyCodeLine{\ \ \ \ \ \ \ "{}manufacturer"{}\ :\ "{}MyCompany"{}}
\DoxyCodeLine{\ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


Note\+: You don\textquotesingle{}t have to restart \doxylink{namespace_unity}{Unity} in order for changes in your layout to take effect on native Devices. The Input \doxylink{namespace_system}{System} applies changes automatically on every domain reload, so you can just keep refining a layout and your Device is recreated with the most up-\/to-\/date version every time scripts are recompiled.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1338}{}\doxysubsection{\texorpdfstring{Disconnected Devices}{Disconnected Devices}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1338}
If you want to get notified when Input Devices disconnect, subscribe to the \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_onDeviceChange}{\texttt{ {\ttfamily Input\+System.\+on\+Device\+Change}}} event, and look for events of type \href{../api/UnityEngine.InputSystem.InputDeviceChange.html}{\texttt{ {\ttfamily Input\+Device\+Change.\+Disconnected}}}.

The Input \doxylink{namespace_system}{System} keeps track of disconnected Devices in \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_disconnectedDevices}{\texttt{ {\ttfamily Input\+System.\+disconnected\+Devices}}}. If one of these Devices reconnects later, the Input \doxylink{namespace_system}{System} can detect that the Device was connected before, and reuses its \href{../api/UnityEngine.InputSystem.InputDevice.html}{\texttt{ {\ttfamily Input\+Device}}} instance. This allows the \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_player_input_manager}{{\ttfamily Player\+Input\+Manager}}{0} to reassign the Device to the same \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_user_management}{user}{0} again.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1339}{}\doxysection{\texorpdfstring{Device IDs}{Device IDs}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1339}
Each Device that is created receives a unique numeric ID. You can access this ID through \href{../api/UnityEngine.InputSystem.InputDevice.html\#UnityEngine_InputSystem_InputDevice_deviceId}{\texttt{ {\ttfamily Input\+Device.\+device\+Id}}}.

All IDs are only used once per \doxylink{namespace_unity}{Unity} session.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1340}{}\doxysection{\texorpdfstring{Device usages}{Device usages}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1340}
Like any \href{../api/UnityEngine.InputSystem.InputControl.html}{\texttt{ {\ttfamily Input\+Control}}}, a Device can have usages associated with it. You can query usages with the \href{../api/UnityEngine.InputSystem.InputControl.html\#UnityEngine_InputSystem_InputControl_usages}{\texttt{ {\ttfamily usages}}} property, and use\href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_SetDeviceUsage_UnityEngine_InputSystem_InputDevice_System_String_}{\texttt{ {\ttfamily Input\+System.\+Set\+Device\+Usage()}}} to set them. Usages can be arbitrary strings with arbitrary meanings. One common case where the Input \doxylink{namespace_system}{System} assigns Devices usages is the handedness of XR controllers, which are tagged with the "{}\+Left\+Hand"{} or "{}\+Right\+Hand"{} usages.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1341}{}\doxysection{\texorpdfstring{Device commands}{Device commands}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1341}
While input \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_events}{events}{0} deliver data from a Device, commands send data back to the Device. The Input \doxylink{namespace_system}{System} uses these to retrieve specific information from the Device, to trigger functions on the Device (such as rumble effects), and for a variety of other needs.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1342}{}\doxysubsection{\texorpdfstring{Sending commands to Devices}{Sending commands to Devices}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1342}
The Input \doxylink{namespace_system}{System} sends commands to the Device through \href{../api/UnityEngine.InputSystem.InputDevice.html\#UnityEngine_InputSystem_InputDevice_ExecuteCommand__1___0__}{\texttt{ {\ttfamily Input\+Device.\+Execute\+Command\texorpdfstring{$<$}{<}TCommand\texorpdfstring{$>$}{>}}}}. To monitor Device commands, use \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_onDeviceCommand}{\texttt{ {\ttfamily Input\+System.\+on\+Device\+Command}}}.

Each Device command implements the \href{../api/UnityEngine.InputSystem.LowLevel.IInputDeviceCommandInfo.html}{\texttt{ {\ttfamily IInput\+Device\+Command\+Info}}} interface, which only requires the \href{../api/UnityEngine.InputSystem.LowLevel.IInputDeviceCommandInfo.html\#UnityEngine_InputSystem_LowLevel_IInputDeviceCommandInfo_typeStatic}{\texttt{ {\ttfamily type\+Static}}} property to identify the type of the command. The native implementation of the Device should then understand how to handle that command. One common case is the {\ttfamily "{}\+HIDO"{}} command type which is used to send \href{HID.md\#hid-output}{\texttt{ HID output reports}} to HIDs.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1343}{}\doxysubsection{\texorpdfstring{Adding custom device Commands}{Adding custom device Commands}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1343}
To create custom Device commands (for example, to support some functionality for a specific HID), create a {\ttfamily struct} that contains all the data to be sent to the Device, and add a \href{../api/UnityEngine.InputSystem.LowLevel.IInputDeviceCommandInfo.html\#UnityEngine_InputSystem_LowLevel_IInputDeviceCommandInfo_typeStatic}{\texttt{ {\ttfamily type\+Static}}} property to make that struct implement the \href{../api/UnityEngine.InputSystem.LowLevel.IInputDeviceCommandInfo.html}{\texttt{ {\ttfamily IInput\+Device\+Command\+Info}}} interface. To send data to a HID, this property should return {\ttfamily "{}\+HIDO"{}}.

You can then create an instance of this struct and populate all its fields, then use \href{../api/UnityEngine.InputSystem.InputDevice.html\#UnityEngine_InputSystem_InputDevice_ExecuteCommand__1___0__}{\texttt{ {\ttfamily Input\+Device.\+Execute\+Command\texorpdfstring{$<$}{<}TCommand\texorpdfstring{$>$}{>}}}} to send it to the Device. The data layout of the struct must match the native representation of the data as the device interprets it.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1344}{}\doxysection{\texorpdfstring{Device state}{Device state}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1344}
Like any other type of \href{Controls.md\#control-state}{\texttt{ Control}}, each Device has a block of memory allocated to it which stores the state of all the Controls associated with the Device.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1345}{}\doxysubsection{\texorpdfstring{State changes}{State changes}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1345}
State changes are usually initiated through \href{Events.md\#state-events}{\texttt{ state events}} from the native backend, but you can use \href{../api/UnityEngine.InputSystem.InputControl-1.html\#UnityEngine_InputSystem_InputControl_1_WriteValueIntoState__0_System_Void__}{\texttt{ {\ttfamily Input\+Control\texorpdfstring{$<$}{<}\texorpdfstring{$>$}{>}.Write\+Value\+Into\+State()}}} to manually overwrite the state of any Control.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1346}{}\doxysubsubsection{\texorpdfstring{Monitoring state changes}{Monitoring state changes}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1346}
You can use \href{../api/UnityEngine.InputSystem.LowLevel.InputState.html\#UnityEngine_InputSystem_LowLevel_InputState_AddChangeMonitor_UnityEngine_InputSystem_InputControl_System_Action_UnityEngine_InputSystem_InputControl_System_Double_UnityEngine_InputSystem_LowLevel_InputEventPtr_System_Int64__System_Int32_System_Action_UnityEngine_InputSystem_InputControl_System_Double_System_Int64_System_Int32__}{\texttt{ {\ttfamily Input\+State.\+Add\+Change\+Monitor()}}} to register a callback to be called whenever the state of a Control changes. The Input \doxylink{namespace_system}{System} uses the same mechanism to implement \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_actions}{input Actions}{0}.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1347}{}\doxysubsubsection{\texorpdfstring{Synthesizing state}{Synthesizing state}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1347}
The Input \doxylink{namespace_system}{System} can synthesize a new state from an existing state. An example of such a synthesized state is the \href{../api/UnityEngine.InputSystem.Pointer.html\#UnityEngine_InputSystem_Pointer_press}{\texttt{ {\ttfamily press}}} button Control that \href{../api/UnityEngine.InputSystem.Touchscreen.html}{\texttt{ {\ttfamily Touchscreen}}} inherits from \href{../api/UnityEngine.InputSystem.Pointer.html}{\texttt{ {\ttfamily Pointer}}}. Unlike a mouse, which has a physical button, for \href{../api/UnityEngine.InputSystem.Touchscreen.html}{\texttt{ {\ttfamily Touchscreen}}} this is a \href{Controls.md\#synthetic-controls}{\texttt{ synthetic Control}} that doesn\textquotesingle{}t correspond to actual data coming in from the Device backend. Instead, the Input \doxylink{namespace_system}{System} considers the button to be pressed if any touch is currently ongoing, and released otherwise.

To do this, the Input \doxylink{namespace_system}{System} uses \href{../api/UnityEngine.InputSystem.LowLevel.InputState.html\#UnityEngine_InputSystem_LowLevel_InputState_Change__1_UnityEngine_InputSystem_InputControl___0_UnityEngine_InputSystem_LowLevel_InputUpdateType_UnityEngine_InputSystem_LowLevel_InputEventPtr_}{\texttt{ {\ttfamily Input\+State.\+Change}}}, which allows feeding arbitrary state changes into the system without having to run them through the input event queue. The Input \doxylink{namespace_system}{System} incorporates state changes directly and synchronously. State change monitors still trigger as expected.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1348}{}\doxysection{\texorpdfstring{Working with Devices}{Working with Devices}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1348}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1349}{}\doxysubsection{\texorpdfstring{Monitoring Devices}{Monitoring Devices}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1349}
To be notified when new Devices are added or existing Devices are removed, use \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_onDeviceChange}{\texttt{ {\ttfamily Input\+System.\+on\+Device\+Change}}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{InputSystem.onDeviceChange\ +=}
\DoxyCodeLine{\ \ \ \ (device,\ change)\ =>}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{switch}\ (change)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ \mbox{\hyperlink{namespace_unity_engine_1_1_input_system_acda9a431e89857409b86e7d7969a448b}{InputDeviceChange}}.Added:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ New\ Device.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ \mbox{\hyperlink{namespace_unity_engine_1_1_input_system_acda9a431e89857409b86e7d7969a448b}{InputDeviceChange}}.Disconnected:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Device\ got\ unplugged.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ \mbox{\hyperlink{namespace_unity_engine_1_1_input_system_acda9a431e89857409b86e7d7969a448b}{InputDeviceChange}}.Connected:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Plugged\ back\ in.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ \mbox{\hyperlink{namespace_unity_engine_1_1_input_system_acda9a431e89857409b86e7d7969a448b}{InputDeviceChange}}.Removed:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Remove\ from\ Input\ System\ entirely;\ by\ default,\ Devices\ stay\ in\ the\ system\ once\ discovered.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{default}:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ See\ InputDeviceChange\ reference\ for\ other\ event\ types.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \}}

\end{DoxyCode}


\href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_onDeviceChange}{\texttt{ {\ttfamily Input\+System.\+on\+Device\+Change}}} delivers notifications for other device-\/related changes as well. See the \href{../api/UnityEngine.InputSystem.InputDeviceChange.html}{\texttt{ {\ttfamily Input\+Device\+Change} enum}} for more information.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1350}{}\doxysubsection{\texorpdfstring{Adding and removing Devices}{Adding and removing Devices}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1350}
To manually add and remove Devices through the API, use \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_AddDevice_UnityEngine_InputSystem_InputDevice_}{\texttt{ {\ttfamily Input\+System.\+Add\+Device()}}} and \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_RemoveDevice_UnityEngine_InputSystem_InputDevice_}{\texttt{ {\ttfamily Input\+System.\+Remove\+Device()}}}.

This allows you to create your own Devices, which can be useful for testing purposes, or for creating virtual Input Devices which synthesize input from other events. As an example, see the \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_on_screen}{on-\/screen Controls}{0} that the Input \doxylink{namespace_system}{System} provides. The Input Devices used for on-\/screen Controls are created entirely in code and have no native representation.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1351}{}\doxysubsection{\texorpdfstring{Creating custom Devices}{Creating custom Devices}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1351}
\texorpdfstring{$>$}{>}{\bfseries{Note}}\+: This example deals only with Devices that have fixed layouts (that is, you know the specific model or models that you want to implement). This is different from an interface such as HID, where Devices can describe themselves through the interface and take on a wide variety of forms. A fixed Device layout can\textquotesingle{}t cover self-\/describing Devices, so you need to use a \href{Layouts.md\#generated-layouts}{\texttt{ layout builder}} to build Device layouts from information you obtain at runtime.

There are two main situations in which you might need to create a custom Device\+:


\begin{DoxyEnumerate}
\item You have an existing API that generates input, and which you want to reflect into the Input \doxylink{namespace_system}{System}.
\item You have an HID that the Input \doxylink{namespace_system}{System} ignores, or that the Input system auto-\/generates a layout for that doesn\textquotesingle{}t work well enough for your needs.
\end{DoxyEnumerate}

For the second scenario, see \href{HID.md\#creating-a-custom-device-layout}{\texttt{ Overriding the HID Fallback}}.

The steps below deal with the first scenario, where you want to create a new Input Device entirely from scratch and provide input to it from a third-\/party API.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1352}{}\doxysubsubsection{\texorpdfstring{Step 1\+: The state struct}{Step 1\+: The state struct}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1352}
The first step is to create a C\# {\ttfamily struct} that represents the form in which the system receives and stores input, and also describes the {\ttfamily Input\+Control} instances that the Input \doxylink{namespace_system}{System} must create for the Device in order to retrieve its state.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ A\ "{}state\ struct"{}\ describes\ the\ memory\ format\ that\ a\ Device\ uses.\ Each\ Device\ can}}
\DoxyCodeLine{\textcolor{comment}{//\ receive\ and\ store\ memory\ in\ its\ custom\ format.\ InputControls\ then\ connect\ to}}
\DoxyCodeLine{\textcolor{comment}{//\ the\ individual\ pieces\ of\ memory\ and\ read\ out\ values\ from\ them.}}
\DoxyCodeLine{\textcolor{comment}{//}}
\DoxyCodeLine{\textcolor{comment}{//\ If\ it's\ important\ for\ the\ memory\ format\ to\ match\ 1:1\ at\ the\ binary\ level}}
\DoxyCodeLine{\textcolor{comment}{//\ to\ an\ external\ representation,\ it's\ generally\ advisable\ to\ use}}
\DoxyCodeLine{\textcolor{comment}{//\ LayoutLind.Explicit.}}
\DoxyCodeLine{[StructLayout(LayoutKind.Explicit,\ Size\ =\ 32)]}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keyword}{struct\ }MyDeviceState\ :\ IInputStateTypeInfo}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ You\ must\ tag\ every\ state\ with\ a\ FourCC\ code\ for\ type}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ checking.\ The\ characters\ can\ be\ anything.\ Choose\ something\ that\ allows}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ you\ to\ easily\ recognize\ memory\ that\ belongs\ to\ your\ own\ Device.}}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ FourCC\ format\ =>\ \textcolor{keyword}{new}\ FourCC(\textcolor{charliteral}{'M'},\ \textcolor{charliteral}{'Y'},\ \textcolor{charliteral}{'D'},\ \textcolor{charliteral}{'V'});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ InputControlAttributes\ on\ fields\ tell\ the\ Input\ System\ to\ create\ Controls}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ for\ the\ public\ fields\ found\ in\ the\ struct.}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Assume\ a\ 16bit\ field\ of\ buttons.\ Create\ one\ button\ that\ is\ tied\ to}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ bit\ \#3\ (zero-\/based).\ Note\ that\ buttons\ don't\ need\ to\ be\ stored\ as\ bits.}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ They\ can\ also\ be\ stored\ as\ floats\ or\ shorts,\ for\ example.\ The}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ InputControlAttribute.format\ property\ determines\ which\ format\ the}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ data\ is\ stored\ in.\ If\ omitted,\ the\ system\ generally\ infers\ it\ from\ the\ value}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ type\ of\ the\ field.}}
\DoxyCodeLine{\ \ \ \ [InputControl(name\ =\ \textcolor{stringliteral}{"{}button"{}},\ layout\ =\ \textcolor{stringliteral}{"{}Button"{}},\ bit\ =\ 3)]}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ ushort\ buttons;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Create\ a\ floating-\/point\ axis.\ If\ a\ name\ is\ not\ supplied,\ it\ is\ taken}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ from\ the\ field.}}
\DoxyCodeLine{\ \ \ \ [InputControl(layout\ =\ \textcolor{stringliteral}{"{}Axis"{}})]}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ \textcolor{keywordtype}{short}\ axis;}
\DoxyCodeLine{\}}

\end{DoxyCode}


The Input \doxylink{namespace_system}{System}\textquotesingle{}s layout mechanism uses \href{../api/UnityEngine.InputSystem.Layouts.InputControlAttribute.html}{\texttt{ {\ttfamily Input\+Control\+Attribute}}} annotations to add Controls to the layout of your Device. For details, see the \doxysectlink{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_layouts}{layout system}{0} documentation.

With the state struct in place, you now have a way to send input data to the Input \doxylink{namespace_system}{System} and store it there. The next thing you need is an \href{../api/UnityEngine.InputSystem.InputDevice.html}{\texttt{ {\ttfamily Input\+Device}}} that uses your custom state struct and represents your custom Device.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1353}{}\doxysubsubsection{\texorpdfstring{Step 2\+: The Device class}{Step 2\+: The Device class}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1353}
Next, you need a class derived from one of the \href{../api/UnityEngine.InputSystem.InputDevice.html}{\texttt{ {\ttfamily Input\+Device}}} base classes. You can either base your Device directly on \href{../api/UnityEngine.InputSystem.InputDevice.html}{\texttt{ {\ttfamily Input\+Device}}}, or you can pick a more specific Device type, like \href{../api/UnityEngine.InputSystem.Gamepad.html}{\texttt{ {\ttfamily Gamepad}}}.

This example assumes that your Device doesn\textquotesingle{}t fit into any of the existing Device classes, so it derives directly from \href{../api/UnityEngine.InputSystem.InputDevice.html}{\texttt{ {\ttfamily Input\+Device}}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ InputControlLayoutAttribute\ attribute\ is\ only\ necessary\ if\ you\ want}}
\DoxyCodeLine{\textcolor{comment}{//\ to\ override\ the\ default\ behavior\ that\ occurs\ when\ you\ register\ your\ Device}}
\DoxyCodeLine{\textcolor{comment}{//\ as\ a\ layout.}}
\DoxyCodeLine{\textcolor{comment}{//\ The\ most\ common\ use\ of\ InputControlLayoutAttribute\ is\ to\ direct\ the\ system}}
\DoxyCodeLine{\textcolor{comment}{//\ to\ a\ custom\ "{}state\ struct"{}\ through\ the\ \`{}stateType`\ property.\ See\ below\ for\ details.}}
\DoxyCodeLine{[InputControlLayout(displayName\ =\ \textcolor{stringliteral}{"{}My\ Device"{}},\ stateType\ =\ typeof(MyDeviceState))]}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keyword}{class\ }MyDevice\ :\ InputDevice}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ In\ the\ state\ struct,\ you\ added\ two\ Controls\ that\ you\ now\ want\ to}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ surface\ on\ the\ Device,\ for\ convenience.\ The\ Controls}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ get\ added\ to\ the\ Device\ either\ way.\ When\ you\ expose\ them\ as\ properties,}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ it\ is\ easier\ to\ get\ to\ the\ Controls\ in\ code.}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ ButtonControl\ button\ \{\ \textcolor{keyword}{get};\ \textcolor{keyword}{private}\ \textcolor{keyword}{set};\ \}}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ AxisControl\ axis\ \{\ \textcolor{keyword}{get};\ \textcolor{keyword}{private}\ \textcolor{keyword}{set};\ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ The\ Input\ System\ calls\ this\ method\ after\ it\ constructs\ the\ Device,}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ but\ before\ it\ adds\ the\ device\ to\ the\ system.\ Do\ any\ last-\/minute\ setup}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ here.}}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{protected}\ \textcolor{keyword}{override}\ \textcolor{keywordtype}{void}\ FinishSetup()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ base.FinishSetup();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ NOTE:\ The\ Input\ System\ creates\ the\ Controls\ automatically.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ This\ is\ why\ don't\ do\ \`{}new`\ here\ but\ rather\ just\ look}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ the\ Controls\ up.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ button\ =\ GetChildControl<ButtonControl>(\textcolor{stringliteral}{"{}button"{}});}
\DoxyCodeLine{\ \ \ \ \ \ \ \ axis\ =\ GetChildControl<AxisControl>(\textcolor{stringliteral}{"{}axis"{}});}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1354}{}\doxysubsubsection{\texorpdfstring{Step 3\+: The Update method}{Step 3\+: The Update method}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1354}
You now have a Device in place along with its associated state format. You can call the following method to create a fully set-\/up Device with your two Controls on it\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{InputSystem.AddDevice<MyDevice>();}

\end{DoxyCode}


However, this Device doesn\textquotesingle{}t receive input yet, because you haven\textquotesingle{}t added any code that generates input. To do that, you can use \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_QueueStateEvent__1_UnityEngine_InputSystem_InputDevice___0_System_Double_}{\texttt{ {\ttfamily Input\+System.\+Queue\+State\+Event}}} or \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_QueueDeltaStateEvent__1_UnityEngine_InputSystem_InputControl___0_System_Double_}{\texttt{ {\ttfamily Input\+System.\+Queue\+Delta\+State\+Event}}} from anywhere, including from a thread. The following example uses \href{../api/UnityEngine.InputSystem.LowLevel.IInputUpdateCallbackReceiver.html}{\texttt{ {\ttfamily IInput\+Update\+Callback\+Receiver}}}, which, when implemented by any \href{../api/UnityEngine.InputSystem.InputDevice.html}{\texttt{ {\ttfamily Input\+Device}}}, adds an \href{../api/UnityEngine.InputSystem.LowLevel.IInputUpdateCallbackReceiver.html\#UnityEngine_InputSystem_LowLevel_IInputUpdateCallbackReceiver_OnUpdate}{\texttt{ {\ttfamily On\+Update()}}} method that automatically gets called during \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_onBeforeUpdate}{\texttt{ {\ttfamily Input\+System.\+on\+Before\+Update}}} and provides input events to the current input update.

\texorpdfstring{$>$}{>}{\bfseries{Note}}\+: If you already have a place where input for your device becomes available, you can skip this step and queue input events from there instead of using \href{../api/UnityEngine.InputSystem.LowLevel.IInputUpdateCallbackReceiver.html}{\texttt{ {\ttfamily IInput\+Update\+Callback\+Receiver}}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keyword}{class\ }MyDevice\ :\ InputDevice,\ IInputUpdateCallbackReceiver}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//...}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ \textcolor{keywordtype}{void}\ OnUpdate()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ In\ practice,\ this\ would\ read\ out\ data\ from\ an\ external}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ API.\ This\ example\ uses\ some\ empty\ input.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ var\ state\ =\ \textcolor{keyword}{new}\ MyDeviceState();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ InputSystem.QueueStateEvent(\textcolor{keyword}{this},\ state);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1355}{}\doxysubsubsection{\texorpdfstring{Step 4\+: Device registration and creation}{Step 4\+: Device registration and creation}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1355}
You now have a functioning device, but you haven\textquotesingle{}t registered it (added it to the system) yet. This means you can\textquotesingle{}t see the device when, for example, you create bindings in the \href{ActionAssets.md\#editing-input-action-assets}{\texttt{ Action editor}}.

You can register your device type with the system from within the code that runs automatically as part of \doxylink{namespace_unity}{Unity}\textquotesingle{}s startup. To do so, modify the definition of {\ttfamily My\+Device} like so\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Add\ the\ InitializeOnLoad\ attribute\ to\ automatically\ run\ the\ static}}
\DoxyCodeLine{\textcolor{comment}{//\ constructor\ of\ the\ class\ after\ each\ C\#\ domain\ load.}}
\DoxyCodeLine{\textcolor{preprocessor}{\#if\ UNITY\_EDITOR}}
\DoxyCodeLine{[InitializeOnLoad]}
\DoxyCodeLine{\textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keyword}{class\ }MyDevice\ :\ InputDevice,\ IInputUpdateCallbackReceiver}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//...}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{static}\ MyDevice()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ RegisterLayout()\ adds\ a\ "{}Control\ layout"{}\ to\ the\ system.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ These\ can\ be\ layouts\ for\ individual\ Controls\ (like\ sticks)}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ or\ layouts\ for\ entire\ Devices\ (which\ are\ themselves}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Controls)\ like\ in\ our\ case.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ InputSystem.RegisterLayout<MyDevice>();}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ You\ still\ need\ a\ way\ to\ trigger\ execution\ of\ the\ static\ constructor}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ in\ the\ Player.\ To\ do\ this,\ you\ can\ add\ the\ RuntimeInitializeOnLoadMethod}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ to\ an\ empty\ method.}}
\DoxyCodeLine{\ \ \ \ [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{private}\ \textcolor{keyword}{static}\ \textcolor{keywordtype}{void}\ InitializeInPlayer()\ \{\}}
\DoxyCodeLine{\}}

\end{DoxyCode}


This registers the Device type with the system and makes it available in the Control picker. However, you still need a way to add an instance of the Device when it is connected.

In theory, you could call \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_AddDevice__1_System_String_}{\texttt{ {\ttfamily Input\+System.\+Add\+Device\texorpdfstring{$<$}{<}My\+Device\texorpdfstring{$>$}{>}()}}} somewhere, but in a real-\/world setup you likely have to correlate the Input Devices you create with their identities in the third-\/party API.

It might be tempting to do something like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keyword}{class\ }MyDevice\ :\ InputDevice,\ IInputUpdateCallbackReceiver}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//...}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ This\ does\ NOT\ work\ correctly.}}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ ThirdPartyAPI.DeviceId\ externalId\ \{\ \textcolor{keyword}{get};\ \textcolor{keyword}{set};\ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


and then set that on the Device after calling \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_AddDevice__1_System_String_}{\texttt{ {\ttfamily Add\+Device\texorpdfstring{$<$}{<}My\+Device\texorpdfstring{$>$}{>}}}}. However, this doesn\textquotesingle{}t work as expected in the Editor, because the Input \doxylink{namespace_system}{System} requires Devices to be created solely from their \href{../api/UnityEngine.InputSystem.Layouts.InputDeviceDescription.html}{\texttt{ {\ttfamily Input\+Device\+Description}}} in combination with the chosen layout (and layout variant). In addition, the system supports a fixed set of mutable per-\/device properties such as device usages (that is, \href{../api/UnityEngine.InputSystem.InputSystem.html\#UnityEngine_InputSystem_InputSystem_SetDeviceUsage_UnityEngine_InputSystem_InputDevice_System_String_}{\texttt{ {\ttfamily Input\+System.\+Set\+Device\+Usage()}}} and related methods). This allows the system to easily recreate Devices after domain reloads in the Editor, as well as to create replicas of remote Devices when connecting to a \doxylink{class_player}{Player}. To comply with this requirement, you must cast that information provided by the third-\/party API into an \href{../api/UnityEngine.InputSystem.Layouts.InputDeviceDescription.html}{\texttt{ {\ttfamily Input\+Device\+Description}}} and then use an \href{../api/UnityEngine.InputSystem.Layouts.InputDeviceMatcher.html}{\texttt{ {\ttfamily Input\+Device\+Matcher}}} to match the description to our custom {\ttfamily My\+Device} layout.

This example assumes that the third-\/party API has two callbacks, like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keyword}{static}\ ThirdPartyAPI}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ This\ example\ assumes\ that\ the\ argument\ is\ a\ string\ that}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ contains\ the\ name\ of\ the\ Device,\ and\ that\ no\ two\ Devices}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ have\ the\ same\ name\ in\ the\ external\ API.}}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ \textcolor{keyword}{static}\ Action<string>\ deviceAdded;}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ \textcolor{keyword}{static}\ Action<string>\ deviceRemoved;}
\DoxyCodeLine{\}}

\end{DoxyCode}


You can hook into those callbacks and create and destroy devices in response.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ This\ example\ uses\ a\ MonoBehaviour\ with\ [ExecuteInEditMode]}}
\DoxyCodeLine{\textcolor{comment}{//\ on\ it\ to\ run\ the\ setup\ code.\ You\ can\ do\ this\ many\ other\ ways.}}
\DoxyCodeLine{[ExecuteInEditMode]}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keyword}{class\ }MyDeviceSupport\ :\ MonoBehaviour}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{protected}\ \textcolor{keywordtype}{void}\ OnEnable()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ThirdPartyAPI.deviceAdded\ +=\ OnDeviceAdded;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ThirdPartyAPI.deviceRemoved\ +=\ OnDeviceRemoved;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{protected}\ \textcolor{keywordtype}{void}\ OnDisable()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ThirdPartyAPI.deviceAdded\ -\/=\ OnDeviceAdded;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ThirdPartyAPI.deviceRemoved\ -\/=\ OnDeviceRemoved;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{private}\ \textcolor{keywordtype}{void}\ OnDeviceAdded(\textcolor{keywordtype}{string}\ name)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Feed\ a\ description\ of\ the\ Device\ into\ the\ system.\ In\ response,\ the}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ system\ matches\ it\ to\ the\ layouts\ it\ has\ and\ creates\ a\ Device.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ InputSystem.AddDevice(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ InputDeviceDescription}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ interfaceName\ =\ \textcolor{stringliteral}{"{}ThirdPartyAPI"{}},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ product\ =\ name}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \});}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{private}\ \textcolor{keywordtype}{void}\ OnDeviceRemoved(\textcolor{keywordtype}{string}\ name)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ var\ device\ =\ InputSystem.devices.FirstOrDefault(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ x\ =>\ x.description\ ==\ \textcolor{keyword}{new}\ InputDeviceDescription}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ interfaceName\ =\ \textcolor{stringliteral}{"{}ThirdPartyAPI"{}},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ product\ =\ name,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (device\ !=\ \textcolor{keyword}{null})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ InputSystem.RemoveDevice(device);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Move\ the\ registration\ of\ MyDevice\ from\ the}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ static\ constructor\ to\ here,\ and\ change\ the}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ registration\ to\ also\ supply\ a\ matcher.}}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{protected}\ \textcolor{keywordtype}{void}\ Awake()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Add\ a\ match\ that\ catches\ any\ Input\ Device\ that\ reports\ its}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ interface\ as\ "{}ThirdPartyAPI"{}.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ InputSystem.RegisterLayout<MyDevice>(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ matches:\ \textcolor{keyword}{new}\ InputDeviceMatcher()}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .WithInterface(\textcolor{stringliteral}{"{}ThirdPartyAPI"{}}));}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1356}{}\doxysubsubsection{\texorpdfstring{Step 5\+: {\ttfamily current} and {\ttfamily all} (optional)}{Step 5\+: {\ttfamily current} and {\ttfamily all} (optional)}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1356}
For convenience, you can quickly access the last used device of a given type, or list all devices of a specific type. To do this, add support for a {\ttfamily current} and for an {\ttfamily all} getter to the API of {\ttfamily My\+Device}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keyword}{class\ }MyDevice\ :\ InputDevice,\ IInputCallbackReceiver}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//...}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ \textcolor{keyword}{static}\ MyDevice\ current\ \{\ \textcolor{keyword}{get};\ \textcolor{keyword}{private}\ \textcolor{keyword}{set};\ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ \textcolor{keyword}{static}\ IReadOnlyList<MyDevice>\ all\ =>\ s\_AllMyDevices;}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{private}\ \textcolor{keyword}{static}\ List<MyDevice>\ s\_AllMyDevices\ =\ \textcolor{keyword}{new}\ List<MyDevice>();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ \textcolor{keyword}{override}\ \textcolor{keywordtype}{void}\ MakeCurrent()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ base.MakeCurrent();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ current\ =\ \textcolor{keyword}{this};}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{protected}\ \textcolor{keyword}{override}\ \textcolor{keywordtype}{void}\ OnAdded()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ base.OnAdded();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ s\_AllMyDevices.Add(\textcolor{keyword}{this});}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{protected}\ \textcolor{keyword}{override}\ \textcolor{keywordtype}{void}\ OnRemoved()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ base.OnRemoved();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ s\_AllMyDevices.Remove(\textcolor{keyword}{this});}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1357}{}\doxysubsubsection{\texorpdfstring{Step 6\+: Device Commands (Optional)}{Step 6\+: Device Commands (Optional)}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8inputsystem_0d1_86_83_2_documentation_0i_2_devices_autotoc_md1357}
A final, but optional, step is to add support for Device commands. A "{}device command"{} is that opposite of input. In other words, it consists of data traveling {\bfseries{to}} the input device, which might also return data as part of the operation (much like a function call). You can use this to communicate with the backend of the device in order to query configuration, or to initiate effects such as haptics. At the moment there isn\textquotesingle{}t a proper interface available for this, however there are still some scenarios that can be solved with the current interfaces.

E.\+g. the following shows, when implementing a non-\/hardware-\/backed device (simulated device), how to simulate hardware reporting that the device can be run in the background and supports sync commands. This is useful to prevent the device from cancelling Actions when application focus is lost and restored. For more info see Device syncs


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{public}\ \textcolor{keyword}{class\ }MyDevice\ :\ InputDevice,\ IInputCallbackReceiver}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//...}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{protected}\ \textcolor{keyword}{override}\ unsafe\ \textcolor{keywordtype}{long}\ ExecuteCommand(InputDeviceCommand*\ commandPtr)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ var\ type\ =\ commandPtr-\/>type;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (type\ ==\ RequestSyncCommand.Type)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Report\ that\ the\ device\ supports\ the\ sync\ command\ and\ has\ handled\ it.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ This\ will\ prevent\ device\ reset\ during\ focus\ changes.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ result\ =\ InputDeviceCommand.GenericSuccess;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (type\ ==\ QueryCanRunInBackground.Type)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Notify\ that\ the\ device\ supports\ running\ in\ the\ background.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ ((QueryCanRunInBackground*)commandPtr)-\/>canRunInBackground\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ result\ =\ InputDeviceCommand.GenericSuccess;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ result\ =\ \textcolor{keywordflow}{default};}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
 