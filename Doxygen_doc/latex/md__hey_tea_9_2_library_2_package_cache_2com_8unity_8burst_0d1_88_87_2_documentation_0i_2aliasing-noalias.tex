\chapter{No\+Alias attribute}
\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing-noalias}{}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing-noalias}\index{NoAlias attribute@{NoAlias attribute}}
\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing-noalias_autotoc_md277}%
\Hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing-noalias_autotoc_md277}%
 Use the \href{xref:Unity.Burst.NoAliasAttribute}{\texttt{ {\ttfamily \mbox{[}No\+Alias\mbox{]}}}} attribute to give \doxylink{namespace_burst}{Burst} additional information on the aliasing of pointers and structs.

In most use cases, you won\textquotesingle{}t need to use the {\ttfamily \mbox{[}No\+Alias\mbox{]}} attribute. You don\textquotesingle{}t need to use it with \href{https://docs.unity3d.com/ScriptReference/Unity.Collections.LowLevel.Unsafe.NativeContainerAttribute.html}{\texttt{ {\ttfamily \mbox{[}Native\+Container\mbox{]}}}} attributed structs, or with fields in job structs. This is because the \doxylink{namespace_burst}{Burst} compiler infers the no-\/alias information.

The {\ttfamily \mbox{[}No\+Alias\mbox{]}} attribute is exposed so that you can construct complex data structures where \doxylink{namespace_burst}{Burst} can\textquotesingle{}t infer the aliasing. If you use the {\ttfamily \mbox{[}No\+Alias\mbox{]}} attribute on a pointer that could alias with another, it might result in undefined behavior and make it hard to track down bugs.

You can use this attribute in the following ways\+:


\begin{DoxyItemize}
\item On a function parameter it signifies that the parameter doesn\textquotesingle{}t alias with any other parameter to the function.
\item On a struct field it signifies that the field doesn\textquotesingle{}t alias with any other field of the struct.
\item On a struct it signifies that the address of the struct can\textquotesingle{}t appear within the struct itself.
\item On a function return value it signifies that the returned pointer doesn\textquotesingle{}t alias with any other pointer returned from the same function.
\end{DoxyItemize}\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing-noalias_autotoc_md278}{}\doxysection{\texorpdfstring{No\+Alias function parameter}{No\+Alias function parameter}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing-noalias_autotoc_md278}
The following is an example of aliasing\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ Foo(ref\ \textcolor{keywordtype}{int}\ a,\ ref\ \textcolor{keywordtype}{int}\ b)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ b\ =\ 13;}
\DoxyCodeLine{\ \ \ \ a\ =\ 42;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ b;}
\DoxyCodeLine{\}}

\end{DoxyCode}


For this, \doxylink{namespace_burst}{Burst} produces the following assembly\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ 86asm}
\DoxyCodeLine{mov\ \ \ \ \ dword\ ptr\ [rdx],\ 13}
\DoxyCodeLine{mov\ \ \ \ \ dword\ ptr\ [rcx],\ 42}
\DoxyCodeLine{mov\ \ \ \ \ eax,\ dword\ ptr\ [rdx]}
\DoxyCodeLine{ret}

\end{DoxyCode}


This means that \doxylink{namespace_burst}{Burst} does the following\+:


\begin{DoxyItemize}
\item Stores 13 into {\ttfamily b}.
\item Stores 42 into {\ttfamily a}.
\item Reloads the value from {\ttfamily b} to return it.
\end{DoxyItemize}

\doxylink{namespace_burst}{Burst} has to reload {\ttfamily b} because it doesn\textquotesingle{}t know whether {\ttfamily a} and {\ttfamily b} are backed by the same memory or not.

Add the {\ttfamily \mbox{[}No\+Alias\mbox{]}} attribute to the code to change this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ Foo([NoAlias]\ ref\ \textcolor{keywordtype}{int}\ a,\ ref\ \textcolor{keywordtype}{int}\ b)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ b\ =\ 13;}
\DoxyCodeLine{\ \ \ \ a\ =\ 42;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ b;}
\DoxyCodeLine{\}}

\end{DoxyCode}


For this, \doxylink{namespace_burst}{Burst} produces the following assembly\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ 86asm}
\DoxyCodeLine{mov\ \ \ \ \ dword\ ptr\ [rdx],\ 13}
\DoxyCodeLine{mov\ \ \ \ \ dword\ ptr\ [rcx],\ 42}
\DoxyCodeLine{mov\ \ \ \ \ eax,\ 13}
\DoxyCodeLine{ret}

\end{DoxyCode}


In this case, the load from {\ttfamily b} has been replaced with moving the constant 13 into the return register.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing-noalias_autotoc_md279}{}\doxysection{\texorpdfstring{No\+Alias struct field}{No\+Alias struct field}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing-noalias_autotoc_md279}
The following example is the same as the previous, but applied to a struct\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{\textcolor{keyword}{struct\ }Bar}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ NativeArray<int>\ a;}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ NativeArray<float>\ b;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ Foo(ref\ Bar\ bar)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ bar.b[0]\ =\ 42.0f;}
\DoxyCodeLine{\ \ \ \ bar.a[0]\ =\ 13;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ (\textcolor{keywordtype}{int})bar.b[0];}
\DoxyCodeLine{\}}

\end{DoxyCode}


For this, \doxylink{namespace_burst}{Burst} produces the following assembly\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ 86asm}
\DoxyCodeLine{mov\ \ \ \ \ rax,\ qword\ ptr\ [rcx\ +\ 16]}
\DoxyCodeLine{mov\ \ \ \ \ dword\ ptr\ [rax],\ 1109917696}
\DoxyCodeLine{mov\ \ \ \ \ rcx,\ qword\ ptr\ [rcx]}
\DoxyCodeLine{mov\ \ \ \ \ dword\ ptr\ [rcx],\ 13}
\DoxyCodeLine{cvttss2si\ \ \ \ \ \ \ eax,\ dword\ ptr\ [rax]}
\DoxyCodeLine{ret}

\end{DoxyCode}


In this case, \doxylink{namespace_burst}{Burst} does the following\+:


\begin{DoxyItemize}
\item Loads the address of the data in {\ttfamily b} into {\ttfamily rax}.
\item Stores 42 into it ({\ttfamily 1109917696} is {\ttfamily 0x42280000}, which is {\ttfamily 42.\+0f}).
\item Loads the address of the data in {\ttfamily a} into {\ttfamily rcx}.
\item Stores 13 into it.
\item Reloads the data in {\ttfamily b} and converts it to an integer for returning.
\end{DoxyItemize}

If you know that the two {\ttfamily Native\+Arrays} aren\textquotesingle{}t backed by the same memory, you can change the code to the following\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{\textcolor{keyword}{struct\ }Bar}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ [NoAlias]}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ NativeArray<int>\ a;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ [NoAlias]}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ NativeArray<float>\ b;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ Foo(ref\ Bar\ bar)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ bar.b[0]\ =\ 42.0f;}
\DoxyCodeLine{\ \ \ \ bar.a[0]\ =\ 13;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ (\textcolor{keywordtype}{int})bar.b[0];}
\DoxyCodeLine{\}}

\end{DoxyCode}


If you attribute both {\ttfamily a} and {\ttfamily b} with {\ttfamily \mbox{[}No\+Alias\mbox{]}} it tells \doxylink{namespace_burst}{Burst} that they don\textquotesingle{}t alias with each other within the struct, which produces the following assembly\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ 86asm}
\DoxyCodeLine{mov\ \ \ \ \ rax,\ qword\ ptr\ [rcx\ +\ 16]}
\DoxyCodeLine{mov\ \ \ \ \ dword\ ptr\ [rax],\ 1109917696}
\DoxyCodeLine{mov\ \ \ \ \ rax,\ qword\ ptr\ [rcx]}
\DoxyCodeLine{mov\ \ \ \ \ dword\ ptr\ [rax],\ 13}
\DoxyCodeLine{mov\ \ \ \ \ eax,\ 42}
\DoxyCodeLine{ret}

\end{DoxyCode}


This means that \doxylink{namespace_burst}{Burst} can return the integer constant 42.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing-noalias_autotoc_md280}{}\doxysection{\texorpdfstring{No\+Alias struct}{No\+Alias struct}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing-noalias_autotoc_md280}
\doxylink{namespace_burst}{Burst} assumes that the pointer to a struct doesn\textquotesingle{}t appear within the struct itself. However, there are cases where this isn\textquotesingle{}t true\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{unsafe\ \textcolor{keyword}{struct\ }CircularList}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ CircularList*\ next;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ CircularList()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ The\ 'empty'\ list\ just\ points\ to\ itself.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ next\ =\ \textcolor{keyword}{this};}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


Lists are one of the few structures where it\textquotesingle{}s normal to have the pointer to the struct accessible from somewhere within the struct itself.

The following example indicates where {\ttfamily \mbox{[}No\+Alias\mbox{]}} on a struct can help\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{unsafe\ \textcolor{keyword}{struct\ }Bar}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ \textcolor{keywordtype}{int}\ i;}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ \textcolor{keywordtype}{void}*\ p;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{float}\ Foo(ref\ Bar\ bar)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ *(\textcolor{keywordtype}{int}*)bar.p\ =\ 42;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ ((\textcolor{keywordtype}{float}*)bar.p)[bar.i];}
\DoxyCodeLine{\}}

\end{DoxyCode}


This produces the following assembly\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ 86asm}
\DoxyCodeLine{mov\ \ \ \ \ rax,\ qword\ ptr\ [rcx\ +\ 8]}
\DoxyCodeLine{mov\ \ \ \ \ dword\ ptr\ [rax],\ 42}
\DoxyCodeLine{mov\ \ \ \ \ rax,\ qword\ ptr\ [rcx\ +\ 8]}
\DoxyCodeLine{mov\ \ \ \ \ ecx,\ dword\ ptr\ [rcx]}
\DoxyCodeLine{movss\ \ \ xmm0,\ dword\ ptr\ [rax\ +\ 4*rcx]}
\DoxyCodeLine{ret}

\end{DoxyCode}


In this case, \doxylink{namespace_burst}{Burst}\+:
\begin{DoxyItemize}
\item Loads {\ttfamily p} into {\ttfamily rax}.
\item Stores 42 into {\ttfamily p}.
\item Loads {\ttfamily p} into {\ttfamily rax} again.
\item Loads {\ttfamily i} into {\ttfamily ecx}.
\item Returns the index into {\ttfamily p} by {\ttfamily i}.
\end{DoxyItemize}

In this situation, \doxylink{namespace_burst}{Burst} loads {\ttfamily p} twice. This is because it doesn\textquotesingle{}t know if {\ttfamily p} points to the address of the struct {\ttfamily bar}. Once it stores 42 into {\ttfamily p} it has to reload the address of {\ttfamily p} from {\ttfamily bar}, which is a costly operation.

Add {\ttfamily \mbox{[}No\+Alias\mbox{]}} to prevent this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{[NoAlias]}
\DoxyCodeLine{unsafe\ \textcolor{keyword}{struct\ }Bar}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ \textcolor{keywordtype}{int}\ i;}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ \textcolor{keywordtype}{void}*\ p;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{float}\ Foo(ref\ Bar\ bar)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ *(\textcolor{keywordtype}{int}*)bar.p\ =\ 42;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ ((\textcolor{keywordtype}{float}*)bar.p)[bar.i];}
\DoxyCodeLine{\}}

\end{DoxyCode}


This produces the following assembly\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ 86asm}
\DoxyCodeLine{mov\ \ \ \ \ rax,\ qword\ ptr\ [rcx\ +\ 8]}
\DoxyCodeLine{mov\ \ \ \ \ dword\ ptr\ [rax],\ 42}
\DoxyCodeLine{mov\ \ \ \ \ ecx,\ dword\ ptr\ [rcx]}
\DoxyCodeLine{movss\ \ \ xmm0,\ dword\ ptr\ [rax\ +\ 4*rcx]}
\DoxyCodeLine{ret}

\end{DoxyCode}


In this situation, \doxylink{namespace_burst}{Burst} only loads the address of {\ttfamily p} once, because {\ttfamily \mbox{[}No\+Alias\mbox{]}} tells it that {\ttfamily p} can\textquotesingle{}t be the pointer to {\ttfamily bar}.\hypertarget{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing-noalias_autotoc_md281}{}\doxysection{\texorpdfstring{No\+Alias function return}{No\+Alias function return}}\label{md__hey_tea_9_2_library_2_package_cache_2com_8unity_8burst_0d1_88_87_2_documentation_0i_2aliasing-noalias_autotoc_md281}
Some functions can only return a unique pointer. For instance, {\ttfamily malloc} only returns a unique pointer. In this case, {\ttfamily \mbox{[}return\+:No\+Alias\mbox{]}} gives some useful information to \doxylink{namespace_burst}{Burst}.

\texorpdfstring{$>$}{>}\mbox{[}!\+IMPORTANT\mbox{]} \texorpdfstring{$>$}{>}Only use {\ttfamily \mbox{[}return\+: No\+Alias\mbox{]}} on functions that are guaranteed to produce a unique pointer. For example, with bump-\/allocations, or with things like {\ttfamily malloc}. \doxylink{namespace_burst}{Burst} aggressively inlines functions for performance considerations, so with small functions, \doxylink{namespace_burst}{Burst} inlines them into their parents to produce the same result without the attribute.

The following example uses a bump allocator backed with a stack allocation\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{\textcolor{comment}{//\ Only\ ever\ returns\ a\ unique\ address\ into\ the\ stackalloc'ed\ memory.}}
\DoxyCodeLine{\textcolor{comment}{//\ We've\ made\ this\ no-\/inline\ because\ Burst\ will\ always\ try\ and\ inline}}
\DoxyCodeLine{\textcolor{comment}{//\ small\ functions\ like\ these,\ which\ would\ defeat\ the\ purpose\ of\ this}}
\DoxyCodeLine{\textcolor{comment}{//\ example}}
\DoxyCodeLine{[MethodImpl(MethodImplOptions.NoInlining)]}
\DoxyCodeLine{unsafe\ \textcolor{keywordtype}{int}*\ BumpAlloc(\textcolor{keywordtype}{int}*\ alloca)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{int}\ location\ =\ alloca[0]++;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ alloca\ +\ location;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{unsafe\ \textcolor{keywordtype}{int}\ Func()}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{int}*\ alloca\ =\ stackalloc\ \textcolor{keywordtype}{int}[128];}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Store\ our\ size\ at\ the\ start\ of\ the\ alloca.}}
\DoxyCodeLine{\ \ \ \ alloca[0]\ =\ 1;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{int}*\ ptr1\ =\ BumpAlloc(alloca);}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{int}*\ ptr2\ =\ BumpAlloc(alloca);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ *ptr1\ =\ 42;}
\DoxyCodeLine{\ \ \ \ *ptr2\ =\ 13;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ *ptr1;}
\DoxyCodeLine{\}}

\end{DoxyCode}


This produces the following assembly\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ 86asm}
\DoxyCodeLine{push\ \ \ \ rsi}
\DoxyCodeLine{push\ \ \ \ rdi}
\DoxyCodeLine{push\ \ \ \ rbx}
\DoxyCodeLine{sub\ \ \ \ \ rsp,\ 544}
\DoxyCodeLine{lea\ \ \ \ \ rcx,\ [rsp\ +\ 36]}
\DoxyCodeLine{movabs\ \ rax,\ offset\ memset}
\DoxyCodeLine{mov\ \ \ \ \ r8d,\ 508}
\DoxyCodeLine{xor\ \ \ \ \ edx,\ edx}
\DoxyCodeLine{call\ \ \ \ rax}
\DoxyCodeLine{mov\ \ \ \ \ dword\ ptr\ [rsp\ +\ 32],\ 1}
\DoxyCodeLine{movabs\ \ rbx,\ offset\ "{}BumpAlloc(int*\ alloca)"{}}
\DoxyCodeLine{lea\ \ \ \ \ rsi,\ [rsp\ +\ 32]}
\DoxyCodeLine{mov\ \ \ \ \ rcx,\ rsi}
\DoxyCodeLine{call\ \ \ \ rbx}
\DoxyCodeLine{mov\ \ \ \ \ rdi,\ rax}
\DoxyCodeLine{mov\ \ \ \ \ rcx,\ rsi}
\DoxyCodeLine{call\ \ \ \ rbx}
\DoxyCodeLine{mov\ \ \ \ \ dword\ ptr\ [rdi],\ 42}
\DoxyCodeLine{mov\ \ \ \ \ dword\ ptr\ [rax],\ 13}
\DoxyCodeLine{mov\ \ \ \ \ eax,\ dword\ ptr\ [rdi]}
\DoxyCodeLine{add\ \ \ \ \ rsp,\ 544}
\DoxyCodeLine{pop\ \ \ \ \ rbx}
\DoxyCodeLine{pop\ \ \ \ \ rdi}
\DoxyCodeLine{pop\ \ \ \ \ rsi}
\DoxyCodeLine{ret}

\end{DoxyCode}


The key things that \doxylink{namespace_burst}{Burst} does\+:


\begin{DoxyItemize}
\item Has {\ttfamily ptr1} in {\ttfamily rdi}.
\item Has {\ttfamily ptr2} in {\ttfamily rax}.
\item Stores 42 into {\ttfamily ptr1}.
\item Stores 13 into {\ttfamily ptr2}.
\item Loads {\ttfamily ptr1} again to return it.
\end{DoxyItemize}

If you add the {\ttfamily \mbox{[}return\+: No\+Alias\mbox{]}} attribute\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\ \#}}
\DoxyCodeLine{[MethodImpl(MethodImplOptions.NoInlining)]}
\DoxyCodeLine{[\textcolor{keywordflow}{return}:\ NoAlias]}
\DoxyCodeLine{unsafe\ \textcolor{keywordtype}{int}*\ BumpAlloc(\textcolor{keywordtype}{int}*\ alloca)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{int}\ location\ =\ alloca[0]++;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ alloca\ +\ location;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{unsafe\ \textcolor{keywordtype}{int}\ Func()}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{int}*\ alloca\ =\ stackalloc\ \textcolor{keywordtype}{int}[128];}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Store\ our\ size\ at\ the\ start\ of\ the\ alloca.}}
\DoxyCodeLine{\ \ \ \ alloca[0]\ =\ 1;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{int}*\ ptr1\ =\ BumpAlloc(alloca);}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{int}*\ ptr2\ =\ BumpAlloc(alloca);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ *ptr1\ =\ 42;}
\DoxyCodeLine{\ \ \ \ *ptr2\ =\ 13;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ *ptr1;}
\DoxyCodeLine{\}}

\end{DoxyCode}


It produces the following assembly\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ 86asm}
\DoxyCodeLine{push\ \ \ \ rsi}
\DoxyCodeLine{push\ \ \ \ rdi}
\DoxyCodeLine{push\ \ \ \ rbx}
\DoxyCodeLine{sub\ \ \ \ \ rsp,\ 544}
\DoxyCodeLine{lea\ \ \ \ \ rcx,\ [rsp\ +\ 36]}
\DoxyCodeLine{movabs\ \ rax,\ offset\ memset}
\DoxyCodeLine{mov\ \ \ \ \ r8d,\ 508}
\DoxyCodeLine{xor\ \ \ \ \ edx,\ edx}
\DoxyCodeLine{call\ \ \ \ rax}
\DoxyCodeLine{mov\ \ \ \ \ dword\ ptr\ [rsp\ +\ 32],\ 1}
\DoxyCodeLine{movabs\ \ rbx,\ offset\ "{}BumpAlloc(int*\ alloca)"{}}
\DoxyCodeLine{lea\ \ \ \ \ rsi,\ [rsp\ +\ 32]}
\DoxyCodeLine{mov\ \ \ \ \ rcx,\ rsi}
\DoxyCodeLine{call\ \ \ \ rbx}
\DoxyCodeLine{mov\ \ \ \ \ rdi,\ rax}
\DoxyCodeLine{mov\ \ \ \ \ rcx,\ rsi}
\DoxyCodeLine{call\ \ \ \ rbx}
\DoxyCodeLine{mov\ \ \ \ \ dword\ ptr\ [rdi],\ 42}
\DoxyCodeLine{mov\ \ \ \ \ dword\ ptr\ [rax],\ 13}
\DoxyCodeLine{mov\ \ \ \ \ eax,\ 42}
\DoxyCodeLine{add\ \ \ \ \ rsp,\ 544}
\DoxyCodeLine{pop\ \ \ \ \ rbx}
\DoxyCodeLine{pop\ \ \ \ \ rdi}
\DoxyCodeLine{pop\ \ \ \ \ rsi}
\DoxyCodeLine{ret}

\end{DoxyCode}


In this case, \doxylink{namespace_burst}{Burst} doesn\textquotesingle{}t reload {\ttfamily ptr2}, and moves 42 into the return register. 